/**
* @file              declarations.c
* @brief             声明是一种引入一个或多个标识符到程序中，并指定其含义及属性的 C 语言构造
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.02
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.02 <td>0.1             <td>brightl         <td>声明定义、使用、特性
* </table>
*/

#include "c/variable/variable.h"
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <assert.h>
#include <stdatomic.h> 
#include <time.h>

/**
* @brief             声明是一种引入一个或多个标识符到程序中，并指定其含义及属性的 C 语言构造
*
* @note              声明可以出现在任何作用域中。每个声明以分号结束（类似语句），并由两 (C23前)三 (C23起)个独立部分组成
*/
#define DECLARATIONS
// 声明  
// 指针
// 数组
// enum
// struct
// union
// 原子类型(C11)
// 位域

// const
// volatile
// restrict(C99)

// 对齐说明符(C11)

// 存储期与链接
// 外部及试探性定义

// typedef

// 静态断言(C11)

// 属性(C23)

/**
* @brief             声明是一种引入一个或多个标识符到程序中，并指定其含义及属性的 C 语言构造
* @return  int       Return Description
*
* @note              声明可以出现在任何作用域中。每个声明以分号结束（类似语句），并由两 (C23前)三 (C23起)个独立部分组成
*/
int declarations_fn(void) {
#ifdef DECLARATIONS
  print_purple("declaration start...\n");
  /*
  声明
  在 C 语言中，声明是一种构造，将一个或多个标识符引入程序中，并指定它们的含义和属性
  声明可以出现在任何作用域中。每个声明都以分号结尾（就像一条语句一样），并且由两部分（C23前）或三部分（C23起）不同的部分组成
  说明符与限定符 声明符与初始化器(可选);        (1)	
  属性说明符序列 说明符与限定符 声明符与初始化器;	(2)	(C23起)
  属性说明符序列;	                           (3) (C23起)
  
  说明符和限定符— 下列以任意顺序排列的由空格分隔的列表
  类型说明符：void、算术类型名、原子类型名、由 typedef 声明在前面引入的名称、struct、union 或 enum 说明符、typeof 说明符 (C23起)
  零或一个存储类说明符：typedef、constexpr、auto、register、static、extern、_Thread_local
  零或多个类型限定符：const、volatile、restrict、_Atomic
  (只在声明函数时）零或多个函数说明符：inline、_Noreturn
  零或多个对齐说明符： _Alignas
  声明符与初始化器- 由声明符组成的以逗号分隔的列表（每个声明符提供额外的类型信息和 / 或要声明的标识符）。声明符可以伴有初始化器。枚举、结构体和联合体声明可以省略声明符，在这种情况下，它们仅引入枚举常量和 / 或标签
  属性说明符序列-	(C23)可选的属性列表，应用到被声明的实体，或若单独出现则构成属性声明

  1-2) 简单声明 引入一个或多个表示对象、函数、结构体 / 联合体 / 枚举标签、类型定义或枚举常量的标识符
  3) 属性声明 不声明任何标识符，如果标准未指定其含义，则具有实现定义的含义
  一个声明引入的每个标识符类型是通过 类型说明符 所指定的类型及其 声明符 所应用的类型修饰决定的

  1、如果使用 auto 说明符，变量的类型也可能被推断出来（C23起）
  2、属性(C23起)可在 说明符与限定符 中出现，在这种情况下，它们适用于由前面的说明符确定的类型
  
  3、声明符 每个声明符是下列之一
  标识符 属性说明符序列(可选)	                                                    (1)	
  ( 声明符 )	                                                                 (2) 
  * 属性说明符序列(可选) 限定符(可选) 声明符	                                      (3)	
  无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]  (4)	
  无指针声明符 ( 形参或标识符 )                                               	  (5)	
  1) 此声明符引入的标识符，即这是最基本的声明形式，就是简单地给出一个标识符（如变量名、函数名等），并且可以选择性地跟上属性说明符序列。属性说明符序列可以用于指定一些额外的属性等（C23起这些属性可在这个位置出现） _Alignas(8) double value;
  2) 任何声明符都可以用括号括起来; 这是引入指向数组的指针和指向函数的指针所必需的，即形式：任何声明符都可以用括号括起来。这种形式看似简单，但它在一些复杂的类型声明场景中非常有用，特别是在声明指向数组的指针和指向函数的指针时是必需的 int (*ptr_to_array)[5]; int (*ptr_to_function)(int, double);
  3) 指针声明符：声明 S * cvr D; 将D声明为受 cvr 限定的指向由 S 确定的类型的指针，即这是用于声明指针的形式。首先是*符号表示指针，然后可以跟上属性说明符序列（用于指定指针相关的额外属性，不过这种情况相对较少见），接着是限定符（如const、volatile等，用于进一步限定指针所指向的类型的特性），最后是另一个声明符，整个式子将最后的声明符所声明的类型确定为指针所指向的类型 _Alignas(4) char * restrict ptr3;
  4) 数组声明符：声明 S D[N] 声明 D 为有 N 个 S 所确定类型对象的数组，无指针声明符是 除未被括号包围的指针声明符 以外的其他任何声明符，即这是用于声明数组的形式。“无指针声明符” 是指除未被括号包围的指针声明符以外的其他任何声明符，先通过前面的部分确定数组元素的类型，然后通过[ static(可选) 限定符(可选) 表达式 ]或[ 限定符(可选) * ]来确定数组的大小或特性 int arr[5]; int arr2[static 3]; double * arr3[const 2];
  5) 函数声明符：声明 S D(params) 声明 D 为接收参数 params 并返回 S 的函数，无指针声明符是 除未被括号包围的指针声明符 以外的其他任何声明符，即这是用于声明函数的形式。“无指针声明符” 同样是指除未被括号包围的指针声明符以外的其他任何声明符，先通过前面的部分确定函数的返回类型，然后通过( 形参或标识符 )来确定函数的参数情况
  这种语法背后的推理是，当由声明符声明的标识符出现在与声明符形式相同的表达式中时，它将具有由类型说明符序列指定的类型
  这种声明语法背后的关键推理是，当由声明符声明的标识符出现在与声明符形式相同的表达式中时，它将具有由类型说明符序列指定的类型。例如，如果我们声明了一个指针int *ptr，那么当我们在表达式中使用ptr时，比如*ptr = 10;，编译器就知道ptr是一个指向整数的指针，所以可以通过解指针操作（*）来访问和修改所指向的整数的值。同样，对于数组声明int arr[5]，当我们在表达式中使用arr时，编译器就知道它是一个包含 5 个整数的数组，并且可以根据数组的索引规则来访问其中的元素。对于函数声明也是如此，当我们调用一个函数时，编译器根据函数的声明就能准确知道函数的返回类型、参数类型和数量等信息，从而正确地执行函数调用和处理返回值
  通过这样一套声明规则，C 语言能够精确地表达各种复杂的类型关系，使得程序员可以准确地定义和使用不同类型的变量、指针、数组和函数等，同时也让编译器能够准确地理解程序的意图并进行正确的编译处理

  4、每个不是另一个声明符一部分的声明符末尾都是一个 “序列点”
  序列点（Sequence Point）的概念 在 C 和 C++ 语言中，序列点是程序执行过程中的一个特殊点，在这个点上，所有的副作用（side - effect）都已经完成，并且后续对同一对象的访问将看到这些副作用的结果。副作用是指对一个对象（如变量）进行修改的操作，例如赋值操作。序列点保证了程序执行的顺序和逻辑的确定性，避免了在复杂表达式求值过程中由于不同的求值顺序可能导致的歧义
  声明符与序列点的关系 当一个声明符不是另一个声明符的一部分时，它的末尾被视为一个序列点。这意味着在这个位置，之前声明过程中可能产生的任何副作用（实际上在声明过程中通常没有副作用，但从语法规则角度这样定义更严谨）都已经完成
  例如，在声明多个变量时：int a = 1, b = a + 1;，在变量a声明结束的位置（也就是第一个声明符int a = 1的末尾）是一个序列点。这样，在初始化b时，a的值已经被确定为1，编译器就可以按照正确的顺序来处理这个初始化表达式，不会出现因为a的值不确定而导致b的初始化出现歧义的情况
  这种规则有助于编译器正确地解析和处理声明语句，特别是在涉及复杂的初始化表达式和多个变量声明的情况下。它保证了变量的初始化顺序和赋值操作按照预期的顺序进行，从而确保程序的正确性和可预测性。如果没有这样的规则，在复杂的声明语句中，编译器可能会因为不确定求值顺序而产生错误的代码生成或者无法正确处理声明

  在所有情况下，属性说明符序列是一个可选的属性序列（自 C23 起）。当紧接在标识符后面出现时，它适用于正在声明的对象或函数
  
  5、定义
  定义是一种声明，它提供了关于其所声明的标识符的所有信息
  每个 enum 或 typedef 的声明都是一个定义
  对于函数，包含函数体的声明是一个函数定义
  对于对象而言，分配存储（自动存储或静态存储，但不是外部存储）的声明是定义，而不分配存储（外部声明）的声明不是定义
  对于结构体和联合体，指定其成员列表的声明是定义

  6、重声明
  如果在同一作用域中，对于相同标识符的另一个声明已在前面出现，那么声明不能引入该标识符，除非
  具有链接（外部或内部）的对象声明可以重复
  非可变长度数组（Non-VLA）类型别名（typedef）只要命名的是相同类型就可以重复
  struct（结构体）和union（联合体）声明可以重复
  这些规则会简化头文件的使用

  7、声明注解
  在 C89 中，任何复合语句（块作用域）内的声明必须出现在块的开头，在任何语句之前
  这样规定的主要原因是为了让编译器在处理复合语句时能够更清晰、有序地管理变量的作用域和内存分配等操作。在代码阅读和理解上，也使得变量的声明集中在块的开头，便于开发者快速了解在该块内会使用哪些变量。但这种规定也有一定的局限性，比如在一些复杂的逻辑中，如果需要根据前面语句的执行结果来动态决定是否声明某个变量，就会受到限制，不过这在 C89 之后的标准（如 C99 等）中有了改进，允许在块内更灵活地声明变量

  此外，在 C89 中，返回整数类型的函数可以通过函数调用运算符隐式声明，并且在使用旧式函数定义时，类型为整数的函数参数不必声明
  在 C89 中，返回整数类型的函数可以通过函数调用运算符隐式声明。这意味着如果在程序中调用了一个尚未显式声明的函数，并且该函数最终返回的是整数类型，编译器会自动为其生成一个隐式声明，默认该函数接受任意数量的参数（实际上这种行为可能会带来潜在的错误风险）

  空声明符是被禁止的；一个简单声明必须至少有一个声明符，或者声明至少一个结构体 / 联合体 / 枚举标签，或者引入至少一个枚举常量
  int ; // 这就是一个空声明符的错误示例，只是写了数据类型 'int'，但没有指定具体要声明的对象（如变量名等），因为它没有明确地告诉编译器要创建和处理什么样的对象，编译器无法确定后续该如何为这个未明确的对象分配内存、处理其类型相关操作等，所以这样的代码在编译时会报错

  如果声明符的任何部分是可变长度数组（VLA）声明符，则整个声明符的类型被称为 “可变修改类型”。由可变修改类型定义的类型也是可变修改的（VM），即由可变修改类型定义的类型也是可变修改的：一旦某个类型被判定为可变修改类型，那么由它所定义的其他类型也会继承这种可变修改的特性。比如，如果有一个函数的参数类型是上述提到的指向可变长度数组的指针（可变修改类型），那么在函数内部使用该参数来定义新的类型时，新的类型也依然是可变修改类型
  任何可变修改类型的声明只能出现在块作用域或函数原型作用域，不能是结构体或联合体的成员。尽管可变长度数组（VLA）只能具有自动存储期或分配的存储期，但诸如指向 VLA 的指针这样的可变修改类型（VM）可以是静态的。对于可变修改类型的使用还有其他限制，参见 goto、switch、longjmp
  只能出现在块作用域或函数原型作用域：可变修改类型的声明有严格的作用域限制。它只能出现在块作用域（也就是在花括号 {} 括起来的代码块内，比如函数体内部的局部变量声明所在的作用域）或者函数原型作用域（在函数声明但未定义具体函数体时，函数参数所在的作用域）
  存储期特性 VLA 本身的存储期限制：可变长度数组（VLA）自身只能具有自动存储期（也就是在进入其所在的函数块时创建，函数块执行结束时销毁）或分配的存储期（通过动态分配内存获得，如使用 malloc 等函数）
  指向 VLA 的指针等可变修改类型的存储期灵活性：尽管 VLA 有存储期限制，但诸如指向 VLA 的指针这样的可变修改类型（VM）却可以是静态的。这意味着可以在程序的静态存储区声明一个指向可变长度数组的指针，它在程序的整个生命周期内都存在，与 VLA 本身的存储期特性有所不同
  参见 goto、switch、longjmp：对于可变修改类型的使用还存在其他一些限制，具体可以参考在涉及 goto 语句、switch 语句以及 longjmp 函数（用于非局部跳转）等相关内容时的情况。比如，在使用 goto 语句进行跳转时，如果跳转目标和源位置涉及到可变修改类型的变量，可能会导致一些未定义行为。这是因为 goto 语句的跳转可能会绕过可变修改类型变量的初始化或其他必要的处理步骤，从而使程序的运行状态变得不可预测。同样，在 switch 语句和 longjump 函数的使用中，也需要特别注意与可变修改类型相关的问题，以避免出现未定义行为

  静态断言 从 C 语法的角度来看被视为声明（因此它们可以出现在任何声明可以出现的地方），但它们不会引入任何标识符，也不遵循声明语法
  属性声明也被视为声明（以便它们可以出现在任何声明可以出现的地方），但它们不会引入任何标识符。单独的; 如果没有属性说明序列，则不是属性声明，而是一条语句（C23起）
  在 C 语言的语法中，一个单独的分号 ; 如果没有前面跟着属性说明符序列，那么它不被看作是属性声明，而是被认定为一条语句，语句在 C 语言程序中是执行某种操作或者表达某种逻辑关系的基本单元。单独的分号作为语句，在语法上是一种空语句，它不执行任何实际的操作，但在程序的语法结构中是合法存在的，并且有时候在程序逻辑需要的情况下会被用到
  */
  int a, *b=NULL;                             // “int”是类型说明符，“a”是声明符，“*b”是声明符， NULL 是初始化器
  const int *f(void);                         // “const”是类型限定符，“int”是类型说明符，“*f(void)”是声明符
  static const _Alignas(8) long long scai;
  inline const long long scaif(void);
  const _Alignas(8) auto int scaai  = 1;      // 1、在 C23 之前，auto关键字主要用于函数内局部变量的声明，它隐含表示变量具有自动存储期（即变量在进入其所在的函数块时创建，函数块执行结束时销毁），但变量的类型需要明确指定
  const _Alignas(8) auto scaa  = 1;           // 2、如果使用 auto 说明符，变量的类型也可能被推断出来（C23起），从 C23 起，auto获得了新的用途，它可以像在 C++ 中那样用于类型推断。这意味着编译器会根据变量的初始化表达式自动推断出变量的类型

  _Alignas(8) double value;                   // 3、标识符 属性说明符序列(可选)，普通声明	
  int (*ptr_to_array)[5];                     // ( 声明符 )，指向数组的指针  
  int (*ptr_to_function)(int, double);        // ( 声明符 )，指向函数的指针	   
  _Alignas(8) char * restrict ptr3;           // * 属性说明符序列(可选) 限定符(可选) 声明符，指针
  int arr[5];                                 // 无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]
  // int arr2[static 3];                      // 无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]
  // double * arr3[const 2];                  // 无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]，'double *' 是无指针声明符（因为这里不是未被括号包围的指针声明符形式）
  double multiply(double num1, double num2);  // 无指针声明符 ( 形参或标识符 )
  int* add(int a, int b);                     // 无指针声明符 ( 形参或标识符 )，'int*' 是无指针声明符（因为这里不是未被括号包围的指针声明符形式）
  
  struct C { int member; } obj, *pObj = &obj;         // “int”是类型说明符，“member”是声明符，“struct C { int member; }”是类型说明符，声明符“obj”定义 struct C 类型的对象，声明符“*pObj”声明指向 struct C 的指针，初始化器“= &obj”提供该指针的初值 
  int ai = 1, *pi = NULL, fi(void), (*pfi)(double);   // 类型说明符是“int”，声明符“ai”定义一个 int 类型对象 初始化器“=1”提供其初值，声明符“*pi”定义一个指向 int 指针类型的对象 初始化器“=NULL”提供其初值，声明符“fi(void)”声明接受 void 并返回 int 的函数，声明符“(*pfi)(double)”定义一个指向接受 double 并返回 int 的函数的指针类型对象
  int (*(*foo)(double))[3] = NULL;                    // foo是一个指向函数的指针，接受double类型参数，返回值是指向3个int元素数组的指针
  // 类型说明符是“int”
  // 1. 声明符“(*(*foo)(double))[3]”是数组声明符：所声明类型是“3 个 int 的数组的 /嵌套声明符/”
  // 2. 嵌套声明符是“（*(*foo)(double)）”，是指针声明符 所声明类型是“/嵌套声明符/ 指向 3 个 int 的数组的指针”
  // 3. 嵌套声明符是“(*foo)(double)”，是一个函数声明符 所声明类型是“/嵌套声明符/ 接受 double 并返回指向 3 个 int 的数组的指针的函数”
  // 4. 嵌套声明符是“(*foo)”，是一个（有括号，函数声明符所要求）指针声明符 所声明类型是“/嵌套声明符/ 指向接受 double 并返回指向 3 个 int 的数组的指针的函数的指针”
  // 5. 嵌套声明符是“foo”，是一个标识符 该声明引入一个标识符“foo”，以指代一个对象，其类型为 “指向接受 double 并返回指向 3 个 int 的数组的指针的函数的指针”
  // 初始化器“= NULL”提供此指针的初值
  // int x = (*(*foo)(1.2))[0];                      // 如果 “foo” 在声明符形式的表达式中被使用，它的类型将是整型 int

  int ax = 1, bx= ax + 1;                            // 4、每个不是另一个声明符一部分的声明符末尾都是一个 “序列点”

  // int foo5(double);                               // 5、声明：函数声明
  // int foo5(double x) { return x; }                // 定义：函数定义：包含函数体
  enum { ONE = 1, TWO } e;                           // 每个 enum 或 typedef 的声明都是一个定义
  typedef int int_t;
  extern int ne;                                     // 声明，对于对象而言，分配存储（自动存储或静态存储，但不是外部存储）的声明是定义，而不分配存储（外部声明）的声明不是定义
  int nel = 10;                                      // 定义 
  struct X;                                          // 声明
  struct X { int n; };                               // 定义，对于结构体和联合体，指定其成员列表的声明是定义

  extern int xl;                                     // 6、有链接对象（外部或内部）的声明可以重复
  extern int xl;                                     // OK
  typedef int int_t; 
  typedef int int_t;                                 // OK，非 VLA typedef 可以任意重复，只要它指名同一类型
  struct X;
  struct X;                                          // OK，struct 和 union 声明可以重复

  int n7;                                            // 7、定义注解
  int arr7[n7];                                      // 这里假设n7是一个在运行时才能确定值的变量，所以arr7是一个可变长度数组（VLA）声明符
  int (*ptr7)[n7];                                   // 因为声明符的一部分（即所指向的类型是可变长度数组int arr7[n7]）是VLA声明符，所以整个声明符（*ptr7）的类型就是可变修改类型
  _Static_assert(2 + 2 * 2 == 6, "Lucky guess!?");   // 静态断言 从 C 语法的角度来看被视为声明（因此它们可以出现在任何声明可以出现的地方），但它们不会引入任何标识符，也不遵循声明语法
  
  /*
  指针，详细移至 pointers.c 文档
  指针是一种对象类型，它引用函数或另一种类型的对象，可以添加限定符。指针亦可以不引用任何内容，这通过一个特定的空指针值指示
  指针是用来存储内存地址的数据类型，可以引用（指向）函数或其他类型的对象。通过指针，可以访问和修改这些对象。指针可以是空指针，表示它不指向任何有效对象或函数。指针还可以添加限定符，如 const，以限制其使用

  指针语法
  类型说明符序列 * 属性说明符序列(可选) 限定符序列(可选) 声明符
  在指针声明的声明文法中：
  类型说明符序列 代表所指向的类型可以是函数或对象类型也可以是不完整类型、
  属性说明符序列 属性在C23引入应用到被声明的指针的可选属性列表
  限定符序列 包括 const、volatile等修饰符它们修饰指针或指针所指向的对象
  指针符号 * 
  声明符 包含指针的标识符以及指针的层次结构例如指向指针的指针

  使用：指针用于间接使用，这是种普遍存在的编程技巧；它们可以用于实现按引用传递语义，访问有动态存储期的对象，实现“可选”类型（使用空指针值），结构体间的聚合关系，回调（使用指向函数指针），泛型接口（使用指向 void 的指针）以及其他更多
  按引用传递语义 在函数调用时，我们通常按值传递参数，这意味着函数得到的是参数的一个副本。有时我们希望函数能够直接修改传递给它的变量，这时可以使用指针来实现按引用传递
  访问有动态存储期的对象 通过动态内存分配（如 malloc 和 free），我们可以在运行时分配和释放内存，这些内存块的生命周期可以跨越函数调用
  实现 “可选” 类型 指针可以用来表示一个“可选”值（例如，指针为 NULL 表示没有值）
  结构体间的聚合关系 通过指针，可以实现结构体之间的聚合关系，例如链表、树等数据结构，结构体之间的聚合关系是一种常见的设计模式，它允许一个结构体包含另一个结构体的实例或指针。这种关系可以通过指针来实现，使得不同结构体能够协同工作，彼此引用，从而构建更复杂的数据结构和系统
  回调（使用指向函数的指针）函数指针可以用来实现回调机制，使得函数的行为可以在运行时灵活变化
  泛型接口（使用指向 void 的指针）void 指针可以指向任何类型的数据，常用于实现泛型接口

  1、指向对象的指针
  对象指针初始化 指向对象的指针可以通过应用于对象类型（可以不完整）表达式的取址运算符初始化，即指针初始化可以通过应用于对象类型表达式的取址运算符来初始化指向对象的指针
  * 一元运算符(对象) 指针可以出现作为间接运算符（一元 *）的操作数，它返回标识所指向对象的左值，即在 C 语言中，指针可以通过间接运算符（即一元 *）来访问它所指向的对象，可以通过这种方式对指针所指向的对象进行读取和修改操作，指针在操作内存和变量时使得我们能够通过指针间接访问和操作变量的值
  -> 运算符(结构体联合体) 指向结构体和联合体类型的对象的指针亦可作为经由指针的成员访问运算符 -> 的左操作数出现，在 C 语言中，当我们使用指针指向结构体或联合体类型的对象时，可以通过箭头运算符 -> 来访问结构体或联合体的成员。这种运算符的使用简化了指针操作，使得代码更加易读
  隐式转换算术运算(数组) 因为数组到指针具有隐式转换，指向数组首元素的指针可通过数组类型表达式初始化，有一些加法、减法、复合赋值、自增和自减运算符对指向数组元素的指针有定义，在 C 语言中，数组名在大多数表达式中会被隐式转换为指向其第一个元素的指针。这使得我们可以方便地通过数组名来初始化指向数组元素的指针。此外，指向数组元素的指针也可以进行一些指针运算，如加法、减法、自增和自减运算等
  指针比较运算符 比较运算符在一些情况下对指向对象的指针有定义：两个表示相同地址的指针比较相等，两个空指针值比较相等，比较指向同一数组的元素的指针以两个元素的数组下标进行比较，以及指向结构体成员的指针以这些成员的声明顺序进行比较，许多实现亦提供对任意来源指针的严格全序，例如若它们实现在连续（“平直”）的虚拟地址空间上，关键点 比较相同地址的指针、空指针比较、指向同一数组的指针比较、指向结构体成员的指针比较、任意来源指针的严格全序
   
  2、指向函数的指针
  函数的指针初始化 指向函数的指针可由函数地址初始化。因为函数到指针转换，取址运算符是可选的
  函数传递 不同于函数，指向函数的指针是对象，从而能存储在数组中，被复制、赋值，作为参数传递给其他函数等等
  函数指针调用 指向函数的指针可以用作函数调用运算符的左操作数；这会调用所指向的函数，即指向函数的指针可以用作函数调用运算符 () 的左操作数，这意味着你可以通过函数指针来调用它所指向的函数，函数指针的定义：函数指针是一个指向函数的指针。它可以存储函数的地址，从而可以通过这个指针来调用函数、用函数指针调用函数：当一个函数指针指向一个函数后，可以像普通函数一样使用函数调用运算符 () 来调用这个函数
  解引用 对函数指针进行解引用会得到所指向函数的函数指示符
  函数比较 相等性比较运算符定义于指向函数的指针（若指向相同函数则它们比较相等）因为函数类型的兼容性忽略函数形参的顶层限定符，指向仅在形参的顶层限定符有区别的函数指针是可互换的，即在 C 语言中，函数指针可以用来指向函数，并且可以通过比较运算符来判断两个函数指针是否指向同一个函数。此外，函数类型的兼容性规则会忽略函数形参的顶层限定符（如 const 和 volatile），因此这些限定符不会影响函数指针的比较和互换性
  
  3、指向 void 类型的指针
  指向任意类型对象的指针能隐式转换成指向 void 的指针（可选地有 const 或 volatile 限定），反之亦然
  指向 void 的指针用于传递未知类型的对象，这在泛型接口中常用：malloc 返回 void*，qsort 期待用户提供接受两个 const void* 实参的回调。pthread_create 期待用户提供接受并返回 void* 的回调。所有情况下，调用方负责在使用前将指针转换到正确的类型，即在 C 语言中，void* 类型的指针是一种通用指针类型，可以指向任何类型的对象。这使得 void* 非常适合用于泛型接口，例如内存分配、排序函数和多线程编程
  
  4、空指针
  每种类型的指针都有一个特殊的值，称为该类型的 “空指针值”。值为 null 的指针不指向任何对象或函数（解引用空指针是未定义行为），并且与同一类型值也为 null 的所有指针比较相等
  要将指针初始化为 null 或者将 null 值赋给已有的指针，可以使用空指针常量（如 “NULL” 或者任何其他值为零的整数常量）。“静态初始化” 也会将指针初始化为它们的 null 值
  空指针可以表示对象不存在，也可以用于表示其他类型的错误情况。通常，接收指针参数的函数几乎总是需要检查该值是否为空，并以不同的方式处理这种情况（例如，当传递空指针时，free不执行任何操作）

  5、在 C 语言中，指针和类型转换涉及许多复杂的规则和未定义行为
  严格别名规则 严格别名规则规定，解引用一个指针时，如果该指针的类型与对象的声明类型不同，则几乎总是会导致未定义行为。这是为了优化编译器的代码生成
  restrict 关键字 restrict 关键字是在 C99 中引入的，用于指示一个指针是唯一访问某一块内存的手段。这意味着通过该指针访问的内存不会被其他指针别名，从而允许编译器进行更多的优化
  数组到指针的转换 在大多数情况下，数组类型的左值表达式会隐式转换成指向数组首元素的指针。这个转换称为“数组到指针转换” 个别情况见 arrays.c 说明
  指针指向char类型 在 C 语言中，指向 char 类型的指针通常用于表示字符串。字符串是以 '\0'（空字符）结尾的 char 数组。为了表示合法的字符串，指针必须指向 char 数组的元素，并且数组中必须有一个或多个 '\0' 字符以示字符串的结束
  */
  float *p;            // 简单指向对象的指针 类型说明符序列 float 说明指针 p 指向 float 类型的对象、声明符 *p 表示 p 是一个指针，指向 float 类型
  float **pp;          // 指向指针的指针 类型说明符序列 float 说明指针 pp 指向的是一个指向 float 类型对象的指针、声明符 **pp 表示 pp 是一个指向指针的指针，而这个指针指向 float 类型
  int (*fp)(int);      // 指向函数的指针 类型说明符序列 int 说明 fp 最终指向的函数返回 int 类型、声明符 (*fp)(int) 表示 fp 是一个指向函数的指针，这个函数接受一个 int 参数，返回 int 类型
  // int* fn(int);     // 返回指针的函数 类型说明符序列 int*，表示返回一个指向 int 的指针、声明符 fn(int) 表示 fn 是一个函数，这个函数接受一个 int 参数，并返回一个 int* 类型的值
  const int *pc;       // 带限定符的指针 pc 是一个指向 const int 的指针，这意味着通过 pc 不能修改它所指向的 int 值
  int * const cp;      // 带限定符的指针 cp 是一个 const 指针，指向一个 int，这意味着 cp 本身不能指向其他地址，但可以修改它所指向的 int 值
  int * const * pcp;   // 带限定符的指针 pcp 是一个指向 const 指针（该指针指向 int）的指针，这意味着 pcp 可以修改所指向的 const 指针
  // [[deprecated]] int *ptr; // 带属性说明符序列的指针(C23起) ptr 是一个指针，指向 int，并且标记为 deprecated

  int *nnp;            // 1、指向对象的指针
  int *const *nnpp;
  int ** const nnpp1;
  int (*arrp)[2];
  int (*ele)[3][3]; 
  struct S { int n; } s = {1};
  struct S* ssp;

  void (*pf1)(int);    // 2、指向函数的指针                       

  int nv = 1, *pv=&nv; // 3、指向 void 类型的指针
  void* pvv = pv;
  int* pv2 = pvv;
  void* thread_function(void *arg);

  int *nup1 = NULL;    // 4、空指针
  int *nup2 = 0;
  static int *nup3;

  int az = 42;         // 5、指针注解         
  float *pz = (float *)&az;
  int resa[] = {1, 2, 3, 4, 5};
  int *restrict resap = resa;
  int arrays[5] = {1, 2, 3, 4, 5};        
  int *arraysp = arrays;
  char str1p[] = "Hello, World!";                    
  char str2p[] = {'H', 'e', 'l', 'l', 'o', '\0'};    
  char *str1p1 = str1p;                              
  char *str2p2 = str2p;

  /*
  数组，详情移至 arrays.c 文档
  数组是由连续无空隙分配的，拥有特定元素类型的对象构成的。这些对象的数目数量（数组大小）在数组生存期间决不改变
  在数组声明的声明语法中，类型说明符的序列指定元素类型（必须是一个完整对象类型如 int、char），声明符 的形式为 [10]、[restrict 10]
  一般的数组 声明符 的语法
  [static(可选) 限定符(可选) 表达式(可选)] 属性说明符序列(可选)
  [限定符(可选) static(可选) 表达式(可选)] 属性说明符序列(可选)
  未指定大小的 VLA 的声明符（只能出现于函数原型作用域）
  [限定符(可选) * ] 属性说明符序列(可选) 
  表达式 任何无逗号运算符的表达式，表明数组中的元素数量
  限定符 const、restrict 和 volatile 限定符的任意混合，只允许出现于函数形参列表中，它们对数组形参所转换得到的指针类型赋予限定
  属性说明符序列	(C23起)可选的属性列表，应用到被声明的数组

  基本声明形式：int arr[10];，声明一个包含 10 个 int 的数组
  带 const 限定符：void foo(const int arr[10]); 声明一个参数不能修改的数组
  带 static 关键字：void bar(int arr[static 10]); 提示编译器数组至少有 10 个元素
  带 restrict 限定符：void baz(int arr[restrict 10]); 提示编译器优化指针访问
  未指定大小的 VLA：void qux(int n, int arr[n][*]); 声明一个可变长度数组
  属性说明符序列：void fun(int arr[10] [[deprecated]]); 向编译器传达额外信息 

  数组类型有几种变体：已知常量大小的数组、变长度数组，以及未知大小数组
  1、已知常量大小数组 若数组声明符中的 表达式 为整数常量表达式，拥有大于零的值，且元素类型是一种拥有已知常量大小的类型（即元素不是VLA） (C99起)，则声明符声明的是已知常量大小的数组，
  已知常量大小的数组可以用数组初始化器提供它们的初始值
  在函数形参列表中，数组声明符中允许有额外的语法元素：关键词 static 及 限定符，它们可以以任意顺序在大小表达式之前出现（即便省略大小表达式也可以出现它们）
  对于函数中在数组形参的 [ 和 ] 中使用关键词 static 的情况，每次对这种函数函数调用中，实际参数的值必须是一个指向数组首地址的合法指针，该数组至少有 表达式 所指定的元素数目
  若存在 限定符，则它们对数组参数类型所转换得的指针类型赋予限定，在 C 语言中，当函数参数是数组时，在实际传递过程中，数组会自动转换为指向其首元素的指针类型。如果在这个数组参数的声明中存在限定符（比如 const、volatile 等），那么这些限定符会对转换后得到的指针类型施加相应的限定作用

  2、变长度数组 非常量长度数组 若 表达式 不是整数常量表达式，则数组声明器声明一个非常量大小的数组（VLA）
  变长数组（VLA, Variable Length Array）和变长修改类型（VM, Variable Modified type）有一些特定的限制和要求，变长数组 (VLA): 数组的大小在编译时未知，而在运行时确定的数组、变长修改类型 (VM): 包含VLA或者指向VLA的指针的类型
  每次控制流经过该声明时，会求值 表达式（而且它必须每次求值为大于零的值），然后分配数组（对应地，VLA 的生存期在其声明离开作用域时结束）。VLA 实例的大小不会在其生存期中改变，但在另一次经过同一代码时，它可能被分配不同大小
  若大小是 * ，则声明是对于未指定大小的 VLA 的。这种声明只能出现于函数原型作用域，并声明一个完整类型的数组。其实，所有函数原型作用域中的 VLA 声明符都被处理成如同用 * 替换 表达式
  变长数组 非常量长度数组与从它们派生的类型（指向它们的指针，等等）被通称为“可变修改类型”（VM）。任何可变修改类型的对象只能声明于块作用域或函数原型作用域中
  VLA 必须拥有自动或分配存储期，指向 VLA 的指针但不是 VLA 自身亦可拥有静态存储期，VM 类型不能拥有链接
  变长数组 可变修改的类型不能是结构体或联合体的成员，变长数组和变长修改类型不能作为结构体或联合体的成员。原因在于结构体和联合体的大小在编译时必须是确定的，而VLA的大小在编译时是未知的
  C标准允许编译器定义一个宏常量 __STDC_NO_VLA__ 来指示是否支持VLA和VM类型：C99标准: 如果定义为1，表示编译器不支持VLA和VM类型、C11标准（到C23前）: 如果定义为1，表示编译器不支持具有自动存储期的VLA对象，但仍必须支持分配存储期的VLA对象

  3、未知大小数组 若忽略数组声明器中的 表达式，则它声明一个未知大小数组。
  除了函数形参列表中的情况（这种数组被转换成指针），以及有初始化器的情况之外，这种类型都是不完整类型（注意，以 * 代替大小声明的拥有未指定大小的 VLA 是完整类型） (C99起)
  在 struct 定义中，未知大小数组可以作为最后一个元素出现（只要有至少一个其他具名成员），这种情况下，这是称为柔性数组成员的特殊情形。细节见 structure.c 文档

  4、限定符 在C99及以后的标准中，如果数组类型声明中有 const、volatile 或 restrict 限定符，这些限定符实际上应用于数组的元素类型，而不是数组类型本身。这可以通过使用 typedef 来实现
  在C23之前的标准中，数组类型被认为与其元素类型具有相同的限定符。这意味着数组类型本身没有 const、volatile 或 restrict 限定符，只是其元素类型具有这些限定符
  在C23标准中，对数组类型的处理更为严格，数组类型本身被认为具有这些限定符。如果一个数组是 const 的，那么这个数组类型也被认为是 const 的，因此不允许将 const 数组类型转换为 void* 指针
  在C标准中，不允许直接将 _Atomic 限定符应用于数组类型，但允许数组的元素类型是原子类型

  5、赋值 数组类型的对象不是可修改左值，尽管它们可以取地址，但它们不能出现于赋值运算符的左侧。不过，拥有数组成员的结构体是可修改左值，并可以赋值
  在C语言中，数组名本身不是可修改左值。这意味着你不能直接对一个数组整体进行赋值操作。数组名在表达式中通常会被转换为指向其第一个元素的指针，但它不能出现在赋值运算符的左侧
  结构体是可修改左值: 与数组不同，结构体类型的对象是可修改左值。这意味着你可以对结构体整体进行赋值操作。即使一个结构体包含数组成员，结构体整体仍然是可修改的，这是因为结构体在C语言中的定义允许对整个结构体对象进行操作，包括赋值、传递和返回。这些操作会触发对结构体中所有成员（包括数组成员）进行逐成员的赋值或拷贝

  6、数组到指针转换 在C语言中，数组到指针的隐式转换是一种常见的操作。这个转换在特定的上下文中会自动发生，将数组类型的左值表达式转换为指向其第一个元素的指针。这种转换的结果是一个非左值指针，可以用于指向数组的元素
  隐式转换的上下文不会转换为指针的情况：作为取地址运算符（&）的操作数、作为 sizeof 运算符的操作数、作为 typeof 和 typeof_unqual 的操作数（C23起）、作为用于数组初始化的字符串字面量、作为 _Alignof 的操作数（C11起）
  数组类型的左值表达式会隐式转换为指向其首元素的指针：函数参数、表达式中的操作数
  当数组类型用于函数形参列表时，它会转换成对应的指针类型： int f(int a[2]) 和 int f(int* a) 声明同一个函数。因为函数实际参数类型为指针类型，使用数组实参的函数调用会进行一个数组到指针转换；被调用函数无法获得实参数组的大小，所以必须显式传递size  

  7、多维数组 当数组的元素是另一个数组时，我们称数组是多维的
  当用数组到指针转换时，多维数组被转换成指向其首元素的指针，例如指向首行的指针
  若支持 VLA 则 (C11 起)多维数组可以在每一维度可变修改，允许数组的每一维度在运行时动态确定大小。例如，int am2[nm][2*nm] 是一个二维VLA数组，大小在运行时由 nm 决定

  8、零长度数组 在C语言标准中，不允许声明零长度数组。这意味着你不能定义一个长度为零的数组
  一些编译器（特别是C99标准之前）提供零长度数组作为扩展，典型用例是实现柔性数组成员（FAM）。柔性数组成员在结构体中用于定义可变长度的最后一个数组成员

  9、副作用
  可变长度数组（VLA）VLA 是C99引入的一种特性，允许数组的大小在运行时确定，而不是编译时
  大小表达式的副作用：如果VLA的大小表达式中包含副作用，编译器保证这些副作用将正确产生。副作用是指表达式在求值过程中对程序状态的改变，例如++（递增）操作符
  */
  float cats[11], *dogs[17];       // cats 是 11 个 float 组成的数组，dogs 是 17 个指向 float 的指针组成的数组
  const int arrc[10];              // 这声明了一个长度为 10 的 const int 数组 arrc，数组中的元素是常量，这意味着一旦初始化后，其元素值不能被修改
  static int arrs[10];             // 如果声明在函数外 static 关键字使得这个数组的作用域被限制在声明它的文件中（文件作用域），但其生命周期是整个程序运行期间、如果声明在函数内：static 关键字使得数组在函数的多次调用间保持其值（静态局部变量）
  // int arrr[restrict 10];        // 非法 限定符 const、restrict 和 volatile 限定符的任意混合，只允许出现于函数形参列表中，它们对数组形参所转换得到的指针类型赋予限定
  // int arrvla[10][*];            // 非法 若大小是 * ，则声明是对于未指定大小的 VLA 的。这种声明只能出现于函数原型作用域，并声明一个完整类型的数组
  void fool(int arrc[const 10]);
  void bar(int arrs[static 10]);
  void baz(int arrr[restrict 10]);
  void qux(int n, int arrvla[n][*]);

  int n[10];                      // 1、整数常量是常量表达式
  char o[sizeof(double)];         // sizeof 是常量表达式
  enum { MAX_SZ=100 };
  int nea[MAX_SZ];                // 枚举常量是常量表达式
  int arra[5] = {1,2,3};          // 声明 int[5] 数组 且初始化为 1,2,3,0,0
  char str[] = "abc";             // 声明 char[4] 数组 且初始化为 'a','b','c','\0'
  double fa[10] = {0}, fb[20] = {0};
  const int arrct[] = {0, 1, 2, 3}; // 等价于 const int * arrct; 数组作为参数传递时会退化为指针
  volatile int arrvl[] = {0, 1, 2, 3}; // 等价于 volatile int * arrxl; 数组作为参数传递时会退化为指针
  // restrict int arrrt[10];        // 非法 restrict 只能用于指针，而不能直接用于数组声明，int arrrt[10]; int *restrict p = arrrt; // p 是一个指向数组 arrr 的 restrict 指针

  int n1 = 3;                       // 2、变长数组
  int A[n1];                        // 变长数组 可变修改类型的对象声明于块作用域
  int (*p2)[n1];                    // 变长数组指针 可变修改类型的对象声明于块作用域
  void fvla(int m, int C[m][m]);    // 变长数组指针 可变修改类型的对象声明于函数原型作用域
  void quB(int n, int ala[n][*]);   // 变长数组指针 可变修改类型的对象声明于函数原型作用域
  int arrvla[n1];                   // arr 是一个 VLA，具有自动存储期
  int *arrn = malloc(n1 * sizeof(int)); // arrn 是一个 VLA，由 molloc 分配，动态分配内存
  // static int arr[n1];                // 这是不合法的，VLA 不能具有静态存储期，尝试声明一个静态VLA
  int *static_pointer = arr;            // 静态指针指向 VLA，指针具有静态存储期，VLA具有自动存储期
  // struct tag {                       // 可变修改的类型不能是结构体或联合体的成员
  //   int z[n1];                       // 错误： VLA 结构体成员
  //   int (*y)[n1];                    // 错误： VM 结构体成员
  // }; 

  extern int x[];                // 3、未知大小的数组 x 的类型是“边界未知的 int 数组”
  int aun[] = {1,2,3};           // a 的类型是“3 个 int 的数组”
  struct s {int n; double d[];}; // s.d 是柔性数组成员
  struct s *s1 = malloc(sizeof (struct s) + (sizeof (double) * 8)); // 如同 d 是 double d[8]

  typedef int cA[2][3];                         // 4、在这个例子中，typedef 定义了一个二维数组类型 cA。当我们声明 const cA ca 时，实际上我们声明的是一个二维数组，其元素类型是 const int。因此，ca[0] 的类型是 const int*，而不是 int*，这就是为什么尝试将 ca[0] 赋值给 int* 指针 pi 会产生错误
  const cA ca = {{4, 5, 6}, {7, 8, 9}};         // const int 的数组的数组
  int* cpi = ca[0];                             // ca[0] 类型为 const int*
  void *unqual_ptr = ca;                        // C23 前 OK；C23 起错误 C23之前，将一个 const 数组类型转换为 void* 是合法的，因为数组类型本身没有 const 限定符，仅其元素类型有、在C23标准下，这个转换将被视为错误，因为 ca 是一个 const 数组类型，不能转换为一个未限定的 void* 指针
  typedef int tA[2];
  // _Atomic tA ta0 = {0};    // 错误，_Atomic tA ta0 和 _Atomic(tA) ta1 是错误的，因为 _Atomic 不能应用于数组类型
  // _Atomic(tA) ta1 = {0};   // 错误，_Atomic tA ta0 和 _Atomic(tA) ta1 是错误的，因为 _Atomic 不能应用于数组类型
  _Atomic int ta2[2] = {0};  // OK，_Atomic int ta2[2] 和 _Atomic(int) ta3[2] 是合法的，因为它们声明了一个数组，其元素类型是 _Atomic int
  _Atomic(int) ta3[2] = {0}; // OK，_Atomic int ta2[2] 和 _Atomic(int) ta3[2] 是合法的，因为它们声明了一个数组，其元素类型是 _Atomic int

  int aq[3] = {1, 2, 3}, bq[3] = {4, 5, 6};     // 5、赋值
  int arrq[5];
  int *pq = arrq;                               // 合法，arrq 被转换为指向其第一个元素的指针
  // arrq = {1, 2, 3, 4, 5};                    // 错误，不能对数组整体赋值
  int (*pq1)[3] = &aq;                          // OK，可以取地址
  // aq = bq;                                   // 错误，aq 是数组
  struct { int cq[3]; } sq1, sq2 = {3,4,5};
  sq1 = sq2;                                    // OK：可以对拥有数组成员的结构体赋值

  int arrcs[5];                     // 6、数组到指针的转换
  int (*pcs)[5] = &arrcs;           // pcs 是指向数组的指针，当数组作为 & 运算符的操作数时，得到的是数组的地址，而不是数组首元素的指针
  size_t sizecs = sizeof(arrcs);    // sizecs 是数组的大小，单位是字节，当数组作为 sizeof 运算符的操作数时，得到的是数组的大小，而不是指向数组首元素的指针
  typeof(arrcs) another_arrcs;      // another_arrcs 是与 arrcs 类型相同的数组，typeof 和 typeof_unqual 运算符会获得数组的真实类型，而不是进行隐式转换，需要 C23 支持，假设 typeof 是可用的
  char strcs[] = "hello";           // strcs 是字符数组，包含字符串 "hello" 和结尾的 '\0'，字符串字面量用于初始化字符数组时，不会发生隐式转换
  size_t aligncs = _Alignof(arrcs); // aligncs 是数组的对齐要求，_Alignof 运算符会获得数组的对齐要求，而不是进行隐式转换  
  register int rarr[5];             // register 修饰符和数组 如果声明一个数组为 register，则尝试对该数组取地址的行为是未定义的。这是因为 register 修饰符建议编译器将变量存储在寄存器中，而不是内存中，数组通常不适合存储在寄存器中，这是因为 register 修饰符和数组的存储需求冲突，编译器无法保证将数组存储在寄存器中
  // int *rp = &rarr;               // 错误：行为未定义，不能取 `register` 数组的地址  

  int a1[2] = {1, 2};                    // 7、一维数组 元素个数 1，2
  int *pm0 = a1;                         // 指向一维数组的首元素
  int am[2][3] = {{1,2,3}, {4,5,6}};     // 二维数组 2x3 矩阵（2 个元素的数组，每个元素为 3 个 int 的数组）可视作行主导排列的 2x3 矩阵
  int (*pm1)[3] = am;                    // 指向首个 3 个元素行的指针、pm1 是一个指向包含3个整数的数组的指针、am 被隐式转换为指向它的首行的指针，即 int (*)[3] 类型
  int bm[3][3][3];                       // 三维数组 3x3x3 立方体
  int (*pm2)[3][3] = bm;                 // 指向首个 3x3 平面的指针 、pm2 是一个指向 3x3 二维平面的指针、bm 被隐式转换为指向其首个 3x3 平面的指针，即 int (*)[3][3] 类型
  int nm = 10;
  int am2[nm][2*nm];                     // 若支持 VLA 则 (C11起)多维数组可以在每一维度可变修改

  int arrv[0];    // 8、这是非法的，标准C语言不允许声明零长度数组
  struct Sts {    // C99及以后的标准：引入了柔性数组成员的标准语法
    int n;
    int arr[];    // 柔性数组成员，允许在定义结构体时不指定数组大小
  };

  int nval = 5;
  int narrvl[nv];                               // 9、合法的VLA语法，数组大小由变量nv决定
  int nv1 = 5, mv1 = 5;
  size_t szv1 = sizeof(int (*[nv1++])[mv1++]);  // nv1 和 mv1 作为数组大小表达式的一部分，int (*[nv1++])[mv1++]：这是一个指向大小为mv1++的数组的指针数组，其大小为nv1++、sizeof 操作符：计算表达式的大小，而不实际创建该类型的对象，副作用保证：C标准保证在上述表达式中nv1会被自增，mv1也会被自增，但在某些情况下（如sizeof操作的结果不依赖副效应时），mv1可能不会被自增，具体行为：语句执行后，nv1一定会增加1，而mv1可能增加也可能不增加，这取决于编译器的实现和优化

  /*
  枚举类型 enum，详细见 enumerated.c 文档
  枚举类型是独立的类型，其值为包含所有其显示命名的常量（枚举常量）的底层类型的值
  
  enum 属性声明符序列(可选) 标识符(可选) { 枚举项列表 } 
  声明没有固定底层类型的枚举，其中枚举项列表是枚举项的逗号分隔列表（允许尾随的逗号）(C99 起)，每个 枚举项 拥有形式：枚举常量 属性声明符序列 (可选)、枚举常量 属性声明符序列 (可选) = 常量表达式
  enum 属性声明符序列(可选) 标识符(可选) : 类型 { 枚举项列表 } 
  声明固定底层类型为 类型 的枚举(C23起)，其中枚举项列表是枚举项的逗号分隔列表（允许尾随的逗号）(C99 起)，每个 枚举项 拥有形式：枚举常量 属性声明符序列 (可选)、枚举常量 属性声明符序列 (可选) = 常量表达式

  标识符, 枚举常量：是由此声明引入的标识符
  常量表达式：整数常量表达式，其值以 int 类型的值表示(C23前)、若枚举具有固定底层类型则其可以表示为类型的值(C23起)
  属性声明符序列：(C23)可选的属性列表，若出现在 enum 后则应用到整个枚举，若出现在枚举常量后则应用到枚举项

  ? 枚举类型为什么只占4个字节(默认int类型的情况下) ？枚举的大小是按照 enum 中元素最大值所占的内存大小来决定的，不像结构体那样有多少个元素就按各个元素所占字节叠加、当枚举成员的值小于 4 个字节时，占 4 个字节、当枚举成员的值大于 4 个字节时，最大只能是 long long 类型，占 8 个字节

  在枚举说明符的主体中出现的每个枚举常量在封闭作用域中成为一个整数常量，类型为 int（C23前），并且可以在需要整数常量的任何时候使用（例如，作为 case 标签或作为非可变长度数组大小

  C语言中枚举常量（enumeration constant）的类型推导规则 6条
  1、如果是同一枚举常量的重新声明，则为先前声明的类型
  2、对于具有固定基础类型的枚举，则枚举所用为固定类型
  3、如果枚举器列表中没有先前的枚举常量，并且没有带有定义整数常量表达式的显式 =，则为 int
  4、如果使用 = 明确给出，并且整数常量表达式的值可以用 int 表示，则为 int
  5、如果使用 = 明确给出，并且整数常量表达式的值不能用 int 表示，则为整数常量表达式的类型
  6、上一个枚举常量的值的类型加上 1。如果这样的整数常量表达式会溢出或绕过前一个枚举常量的值（从加 1 开始），则该类型将采用以下任一类型：大小合适的有符号整数类型（不包括位精度有符号整数类型），能够表示前一个枚举常量的值加 1、大小合适的无符号整数类型（不包括位精度无符号整数类型），能够表示前一个枚举常量的值加 1
  如果要添加的前一个枚举常量是有符号整数类型，则选择有符号整数类型。如果前一个枚举常量是无符号整数类型，则选择无符号整数类型、如果之前没有大小合适的整数类型可以表示新值，则枚举没有能够表示其所有值的类型
  
  C23标准中，枚举类型的兼容类型和底层类型的选择规则
  1、每个无固定底层类型的(C23起)枚举类型与如下之一兼容：char、有符号整数类型或无符号整数类型（不包括 bool 和位精确整数类型）
  2、对于任何枚举类型，哪一个类型是兼容的是实现定义的，但无论是那种类型，都必须有足以表示该枚举中所有枚举项的值
  3、对于所有具有固定底层类型的枚举，枚举的类型均与枚举的底层类型兼容
  4、没有固定底层类型的枚举类型，在其完成处枚举成员的类型为：如果枚举的所有值均可表示为一个 int 则为 int，否则，为枚举的类型
  5、所有枚举均有底层类型，可以通过用 enum-类型说明符 显式指定底层类型，并作为其固定底层类型，如果未显式指定，则其底层类型为枚举的兼容类型，它为有符号或无符号的整数类型 或 char (C23起)

  1、若 枚举常量 后随 = 常量表达式 ，则其值为该常量表达式的值。若 枚举常量 没有后随 = 常量表达式 ，则其值是比同一枚举中前一枚举项的值大一的值。首个枚举项（若它不用 = 常量表达式 ）的值是零
  2、若使用 标识符 则其自身成为标签命名空间中枚举类型的名称，且需要使用关键词 enum （除非 typedef 到通常命名空间）
  3、枚举类型是整数类型，从而可以用于任何其他整数类型能用之处，包括隐式转换和算术运算符

  引入枚举类型和一或多个枚举常量的声明亦可声明一或多个该类型的对象：引入枚举类型和一或多个枚举常量的声明时，可以同时声明一个或多个该枚举类型的对象。这意味着在定义枚举类型的同时，也可以创建该类型的变量，而不必分两步进行
  局部枚举变量 定义了一个枚举类型 zoo 和两个枚举变量 cats 和 catsp
  zoo 是枚举类型的名称、CAT, DOG, RABBIT 是枚举常量，且紧随声明 cats = CAT <=> enum zoo cats = CAT; 且紧随声明 *catsp = &cats <=> enum zoo *catsp = &cats;

  枚举允许以比 #define 更加便利和结构化的方式生成具名常量；它们可见于调试器，遵循作用域规则，并且参与类型系统
  #define TEN 10
  struct S {int x : TEN;};  // OK
  enum {TEN = 10};
  struct S {int x : TEN;};  // 也 OK
  constexpr int TEN = 10;   (自 C23 起也可用 constexpr 来达成相同目的)
  struct S {int x : TEN;};  // 也 OK

  由于 C 中结构体或联合体不建立其作用域，可以在前者(结构体或联合体)的成员说明中引入枚举类型及其枚举常量，而之后其(枚举类型)作用域与前者(结构体或联合体)相同
  */
  enum color {RED, GREEN, BLUE}; // 全局命名的枚举类型
  enum {MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY}; // 全局匿名的枚举类型
  enum day {MON = 1, TUES, WEDNES, THURS, FRI, SATUR, SUN}; // 全局带有显式值的枚举类型
  enum __attribute__((aligned(4))) log_aligned {INFO, WARN, ERROR}; // 全局带有属性声明符的枚举类型 __attribute__((aligned(8))) 是 GCC 扩展的属性语法，需要在类型名称前使用，为枚举类型设置对齐方式，但是，当该属性用于枚举类型时，并不能达到预期效果。原因在于，枚举类型的对齐方式是由编译器决定的，并且编译器通常会根据枚举的基础类型（通常是 int）来选择对齐方式
  // enum __attribute__((packed)) Status : uint8_t { OK = 0, WARNING = 1, ERROR = 255 }; 声明固定底层类型为 uint8_t 的枚举类型 (C23起)
  typedef enum book {C, CPLUSPLUS, GO, RUST, PYTHON} program_Book; // 使用 typedef 重新定义 enum 类型  
  enum color c = RED;                           // 声明一个 color 枚举类型的变量
  int today = MONDAY;                           // 使用匿名枚举类型的值
  int cr = GREEN;
  enum day tday = WEDNES;                       // 声明一个 day 枚举类型的变量
  enum log_aligned log_level = INFO;            // 声明一个 log_aligned 枚举类型的变量  
  switch(c) // 作为 case 标签 使用
  {
  case RED:
      print_purple("color is red.\n");
      break;
  case GREEN:
      print_purple("color is green.\n");
      break;
  case BLUE:
      print_purple("color is blue.\n");
      break;
  }
  enum color0 { RED1 };
  enum color1 { BLUE1 = RED1 };                               // 1、同一枚举常量的重新声明 ：RED 的类型为 enum Color1
  // enum FixedEnum : unsigned int { A = 1, B = 2 };          // 2、固定基础类型的枚举 ：A 和 B 的类型为 unsigned int
  enum Example { X, Y, Z };                                   // 3、没有先前的枚举常量，没有带有定义整数常量表达式 ：X, Y, Z 都是 int 类型
  enum AnotherExample { M = 1000, N = 2000 };                 // 4、整数常量表达式的值可以用 int 表示 ：M 和 N 都是 int 类型
  enum BigValues { P = 2147483648 };                          // 5、整数常量表达式的值不能用 int ：P 的值超出 int 范围，会被推导为 long
  // enum OverflowExample { Q = 2147483647, R };              // 6、上一个枚举常量的值的类型加上 1 溢出 ：Q 是 int 类型, R = 2147483648, 所以 R 是 long 类型
  enum SignedExample { S = -1, T };                           // 前一个枚举常量是有符号整数类型 ：S 是 int 类型, 所以 T = 0 也是 int 类型
  // enum LargeRange { U = 9223372036854775807, V };          // 没有大小合适的整数类型可以表示新值 ：U 是 long long 类型, V = 9223372036854775808，没有更大的类型来表示
  
  enum Example1 { A1 = 1, B1 = 2 };                             // 1、兼容类型可以是 int 或 unsigned int 等
  enum Example2 { C2 = 1, D2 = 1000000 };                       // 2、假设编译器选择 int 作为兼容类型 兼容类型为 int
  // enum FixedBaseType : unsigned char { ET = 1, FT = 255 };   // 3、E 和 F 的类型为 unsigned char
  enum Example3 { G3 = 1, H3 = 2 };                             // 4、 G 和 H 的类型为 int
  enum Example4 { I4 = 2147483648 };                            // 4、I 的类型为 long 因为值超出 int 范围
  // enum FixedBaseType2 : short { JT = 1, KT = 32767 };        // 5、J 和 K 的底层类型为 short
  enum Example5 { L5 = 1, M5 = 2 };                             // 5、底层类型由实现决定，可以是 int

  enum Foo { A2, B, C1 = 10, D, E = 1, F, G = F + C}; // A=0, B=1, C=10, D=11, E=1, F=2, G=12
  enum color2 { YELLOW, GREEN1, PINK };
  enum color2 cl = YELLOW;                            // 需要使用关键词 enum  OK
  // color2 x = GREEN;                                // ERROR： color2 不在通常命名空间中
  typedef enum color2 color_t;                        // typedef 到通常命名空间
  color_t x1 = GREEN;                                 // OK
  enum { ONE1 = 1, TWO1 } Example6;                   // 枚举类型是整数类型，从而可以用于任何其他整数类型能用之处
  long n2 = ONE;                                      // 提升
  double d = ONE;                                     // 转换
  Example6 = 1.2;                                     // 转换，Example6 现在是 ONE
  Example6 = Example6 + 1;                            // 转换，Example6 现在是 TWO 

  enum zoo {CAT, DOG, RABBIT} cats1 = CAT, *catsp = &cats; // 局部枚举变量 定义了一个枚举类型 zoo 和两个枚举变量 cats 和 catsp
  print_purple("zoo cat of is: %d.\n", cats1);
  print_purple("zoo cat of is: %d. ptr is %p.\n", *catsp, catsp); 
  print_purple("zoo size of is %d. cats is %d. catsp is %d.\n",sizeof(enum zoo), sizeof(cats), sizeof(catsp));
  enum TV { FOX = 11, CNN = 25, ESPN = 15, HBO = 22, MAX = 30, NBC = 32 };
  print_purple("FOX: \t%2d\n", FOX);
  
  enum {TEN = 10};              // 比 #define 更加便利和结构化的方式生成具名常量，这里定义了一个匿名枚举类型，并在其中定义了一个枚举常量 TEN，其值被初始化为 10。与使用 #define 来定义常量相比，枚举常量具有类型安全性（它属于特定的枚举类型，而不是简单的文本替换），并且在代码结构上更加清晰，便于维护和理解
  struct Se {int xe : TEN;} se; // 也 OK  struct S {int x : TEN;} s; 定义了一个结构体 S，其中包含一个成员变量 x，它是一个有符号整数类型（int），并且使用了位域（bit-field）的特性。这里指定 x 的位宽为 TEN，也就是 10 位。这意味着 x 在内存中只会占用 10 位的存储空间来存储其整数值，而不是通常情况下 int 类型所占用的完整位数（通常是 32 位，具体取决于编译器和平台）。然后声明了一个结构体变量 s 属于 S 类型
  se.xe = 511;                  // 只有10位，不是32位4字节
  print_purple("s.x = %d.\n",se.xe);

  struct Element {
    int z;
    enum State {SOLID, LIQUID, GAS, PLASMA} state : 2;
  } oxygen = {8, GAS};
  enum State ee = LIQUID;      // OK 类型 enum State 与其枚举常量于此保持可见 和 struct Element 作用域与可见范围相同
  print_purple("enum State e = %d. enum State state = %d. PLASMA = %d.\n", ee, oxygen.state, PLASMA); // 打印 1 2 3  

  /*
  struct，详细见 structure.c 文档
  结构体（struct）是一种复合数据类型，它由一组按顺序排列的成员组成，每个成员可以是不同类型的变量。与结构体相对的是联合体（union），其成员在内存中是重叠存储的。结构体的定义和声明有特定的语法规则

  声明方式、语法、规则
  1、结构体的基本概念 结构体是一种由一序列的成员组成的类型，成员的存储以顺序分配于内存中、联合体是由一个序列的成员组成的类型，成员存储在内存中重叠
  2、结构体的类型说明符语法 结构体的类型说明符与联合体的类型说明符相同，只是所用的关键词有别（struct 对比 union）
  3、结构体的定义和声明语法 
  struct 属性说明符序列(可选) 名字(可选) {结构体声明列表} 
  struct 属性说明符序列(可选) 名字 
  结构体声明列表：结构体声明列表可以包含任意数量的变量声明、位域声明和静态断言声明，不允许不完整类型的成员和函数类型的成员（除了柔性数组成员）
  属性说明符序列（C23起）可以包含属性的可选列表，应用到结构体类型  

  结构体特性、使用、初始化
  1、结构体成员的地址是按定义顺序递增的
  2、指向结构体的指针可以转换为指向其首成员的指针，反之亦然
  3、位域成员的地址指向其分配单元
  4、在结构体的成员之间和最后可能有填充字节，但首成员前没有填充字节
  5、结构体的大小至少等于其所有成员的大小之和，但由于对齐要求，实际大小可能更大
  6、柔性数组成员 是一种在定义结构体时使用的特殊数组成员，允许我们在不指定数组大小的情况下定义数组成员。柔性数组成员通常用于需要动态分配大小的结构体
  7、匿名结构体是一种特殊的结构体类型，它本身没有名字，直接作为外围结构体或联合体的一部分。因此，匿名结构体的成员可以直接作为外围结构体或联合体的成员来访问
  8、若不以任何具名成员定义结构体（包含经由匿名嵌套结构体或联合体获得的成员），则程序行为未定义，即如果一个结构体没有任何具名成员（即所有成员都是通过匿名嵌套结构体或联合体获得的成员），那么根据标准，访问这些成员的行为是未定义的，这是因为标准要求至少有一个具名成员来确保结构体的有效使用
  9、前置声明 有时需要让一个结构体引用另一个结构体，这种情况经常出现在定义具有相互依赖关系的数据结构时，为了实现这一点，可以使用前向声明（forward declaration），前向声明允许你先声明一个结构体的名字，而不立即定义它的内容。这种结构体名字在定义之前会被视为不完整类型（incomplete type），只能用来声明指针而不能直接使用。这种特性有助于解决结构体彼此引用的问题
  10、不完整类型的成员 结构体初始化规则 在 C 语言中，一个结构体在其定义结束之前是一个不完整类型，这意味着在定义结构体时，不能包含其自身类型的成员，这是因为在结构体定义结束之前，编译器不知道结构体的大小，可以包含指向其自身类型的指针成员，这是合法且常用的，例如在链表和树的实现中
  11、结构体声明的作用域 结构体声明不会建立新的作用域，这意味着在结构体声明列表中引入的嵌套类型、枚举及枚举项在结构体声明的外围作用域中是可见的
  */
  struct Examples { int a; float b; char c; };       // 1、这里，结构体 Example 的成员 a, b 和 c 是按顺序存储在内存中的
  union ExampleUnions { int a; float b; char c; };   // 2、这里，联合体 ExampleUnion 的成员 a, b 和 c 是重叠存储在相同的内存位置
  struct Person { char name[50]; int age; };         // 3、结构体定义：引入一个新类型 struct 名字 并定义其含义 这里定义了一个结构体类型 Person
  struct ForwardDeclaration;                         // 3、若仅在其自身的行使用，如在 struct 名字; 中，声明但不定义 struct 名字，这是一个前向声明，声明了名为 ForwardDeclaration 的结构体类型，但未定义其成员
  struct ForwardDeclaration { int id; double value; }; // 3、在其他语境中，命名先前声明的结构体，并且不允许属性说明符序列，现在定义了之前前向声明的结构体 ForwardDeclaration
  struct ComplexStruct {
    int a;
    unsigned int b: 4;                                       // 位域声明
    _Static_assert(sizeof(int) == 4, "Unexpected int size"); // 静态断言声明
  };                                                 // 4、结构体声明列表可以包含任意数量的变量声明、位域声明和静态断言声明  
  struct InvalidStruct {
    int a;
    // int incompleteMember[];                               // 这是不允许的，因为这是不完整类型的成员，注释掉的 int incompleteMember[]; 是一个不完整类型的成员，因为数组的大小未定义，这在结构体中是不允许的
    // void func();                                          // 这是不允许的，函数类型的成员，在C语言中，结构体成员不能是函数类型，然而，它们可以是函数指针类型，在 struct InvalidStruct 中，void func(); 是一个函数声明，这是不允许的，可以使用函数指针来替代
  };                                                 // 4、不允许不完整类型的成员和函数类型的成员（除了柔性数组成员），不完整类型是指类型的大小未知或未定义例如，未指定数组大小的数组类型就是一种不完整类型，在结构体中，成员必须是完整类型，这样编译器才能确定每个成员在内存中的大小和偏移位置
  struct ValidStructWithFuncPtr {
    int a;
    void (*func)();                                          // 这是一个函数指针，指向返回类型为 void 且无参数的函数
  };
  struct ValidStruct {
    int a;
    int flexibleArray[];                                     // 柔性数组成员，这是允许的，柔性数组成员是C语言的一种特殊数组成员，它允许在结构体的末尾定义一个大小不确定的数组。柔性数组成员的前提是结构体中必须有其他成员，并且柔性数组成员必须是结构体中的最后一个成员，柔性数组成员在定义结构体变量时，可以根据需要具体分配数组的大小
  };
  // struct [[nodiscard]] EnhancedStruct {
  //   int importantValue;
  // };                                             // 5、可以包含属性的可选列表，应用到结构体类型（C23起    
  typedef struct typeStruct {
    int a;
    float b;
  } tStruct;                            // 使用 typedef 重新定义 struct 类型、提升命名空间
  struct qs* pss = NULL;                // 声明一个指向 struct qs 的指针 pss
  struct qs { int a; };                 // 定义 struct qs，包含一个整型成员 a 

  struct Examplesc {
    int a;
    float b;
    char c;
  };
  struct Examplesc example;            // 1、在结构体对象内，其成员的地址按照成员定义的顺序递增，这意味着在内存中，结构体成员是按它们在结构体定义中的顺序排列的：&example.a < &example.b < &example.c
  struct Examplesc *ptrStruct = &example;
  int *ptrInt = (int *)ptrStruct;                                  // 2、指向结构体的指针可以转换为指向其首成员的指针，反之亦然，ptrInt 指向 example.a
  struct Examplesc *ptrStruct2 = (struct Examplesc *)ptrInt;       // 2、首成员的指针逆转位结构体的指针，ptrInt 指向结构体 ptrStruct2
  struct BitFieldExample {                                         // 3、若首成员为位域，则指向其分配单元的指针，位域成员是特殊的按位存储的成员。虽然不能直接获取位域成员的地址，但可以获取其分配单元的地址，位域（bit field）是 C 语言中的一种特殊结构体成员，允许你以 位 为单位定义结构体成员的大小，位域通常用于节省内存或实现硬件寄存器的映射                                       
    unsigned int a : 3;                                         // 占用3个位
    unsigned int b : 5;                                         // 占用5个位
  };                                                            // 这个例子中，struct BitFieldExample 有两个位域成员 a 和 b。成员 a 占用3个位，成员 b 占用5个位
  struct BitFieldExample bitexample;                            // 由于位域成员是按位存储的，不能直接获取它们的地址，这是因为C语言标准不允许对位域成员取地址，但可以获取包含这些位域的分配单元的地址
  // unsigned int *bptr = &example.a;                           // 错误，无法获取位域成员的地址，bitexample.a 和 bitexample.b 共享一个 unsigned int 类型的分配单元，如果我们尝试获取 a 或 b 的地址，编译器会报错
  unsigned int *bptr = (unsigned int *)&bitexample;             // 获取分配单元的地址，可以获取包含位域的分配单元的地址，即整个结构体的地址
  struct BitFieldExample bitexample1 = { 5, 3 };
  unsigned int *bitptr = (unsigned int *)&bitexample1;          // 获取分配单元的地址   
  print_purple("Value of the allocation unit: %u\n", *bitptr);  // 打印分配单元的值，5 的二进制表示是 101（3 位），3 的二进制表示是（5 位需要写作 00011），合并位域在内存中，a 和 b 会被合并到同一个分配单元（通常是一个 unsigned int），其合并为一个 8 位的二进制数 00011 101，这个二进制数可以被解释为一个 unsigned int，为了便于解释，我们将其扩展为 32 位 0000 0000 0000 0000 0000 0000 0011 101 这个二进制数转换为十进制是 53
  print_purple("Binary output of the allocation unit: ");       // unsigned int 只用了 8 位，其余位数未定义，因为内存对齐或结构填充策略导致的      
  struct BitFieldExample3 {
    unsigned int a : 3;
    unsigned int b : 5;
    unsigned int c : 6;
    unsigned int d : 20; // 如果加上这个成员，编译器可能会使用新的分配单元，假设 unsigned int 是32位（4字节），那么 a 和 b 、c 会共享同一个 unsigned int 分配单元，如果加上成员 d，编译器可能会在需要时使用新的分配单元
  };
  print_purple("Size of struct BitFieldExample3: %zu\n", sizeof(struct BitFieldExample3));
  struct BitFieldExample3 bitexample3 = {5, 3, 25, 1};   //  unit 1：011001 00011 101 、unit 2：0000 0000 0000 0000 0001
  unsigned int *bitptr3 = (unsigned int *)&bitexample3;  //  获取分配单元的地址
  print_purple("bitptr3 = %p, bitptr3[0] = %p, bitptr3[1] = %p.\n", bitptr3, &bitptr3[0], &bitptr3[1]);
  print_purple("Value of the allocation unit 1: %u\n", bitptr3[0]);   // 打印分配单元的值 unit 1
  print_purple("Value of the allocation unit 2: %u\n", bitptr3[1]);   // 打印分配单元的值 unit 2
  print_purple("Binary output of the allocation unit 1: "); // 打印二进制表示 unit 1
  for (int i = 31; i >= 0; i--) {
    print_purple("%d", (bitptr3[0] >> i) & 1);
  }
  print_purple("\n");
  print_purple("Binary output of the allocation unit 2: "); // 打印二进制表示 unit 2
  for (int i = 31; i >= 0; i--) {
    print_purple("%d", (bitptr3[1] >> i) & 1);
  }
  print_purple("\n");
  struct Example2sc {                                                              // 4、在任意两个成员间和最后的成员后可能存在无名的填充字节，但首成员前不会有，填充字节（padding bytes）是编译器为了对齐（alignment）成员而插入的字节，对齐是为了提高内存访问效率，例如，某些架构可能要求 int 类型变量在 4 字节边界对齐，如果一个 char 类型成员后面紧跟一个 int 类型成员，编译器可能会插入填充字节来满足对齐要求
    char c;  // 1 byte
    int i;   // 4 bytes, may be aligned to 4-byte boundary
  };                                                                               // 4、内存布局可能是：[c][padding][i][i][i][i]
  struct Example3sc {                                                              // 5、结构体的大小至少与其成员的大小之和一样大，这意味着结构体的大小不仅包括所有成员的大小，还可能包含填充字节
    char c;  // 1 byte
    int i;   // 4 bytes, but aligned to 4-byte boundary
  };
  print_purple("Size of struct: %zu\n", sizeof(struct Example3sc));                // 5、可能输出 8，结构体大小至少是 5 bytes，但由于对齐要求，实际大小可能是 8 bytes.
  struct FlexArrayStruct {                                                         // 6、定义结构体：结构体中拥有至少一个具名成员，并在结构体的最后一个成员定义一个数组但不指定大小，动态分配内存：在实际使用时，通过动态分配内存的方式为结构体分配额外的空间，以容纳柔性数组成员所需的内存，访问柔性数组成员：访问柔性数组成员时，结构体表现得好像该数组成员拥有分配的额外内存的部分
    int count;   // 具名成员
    char data[]; // 柔性数组成员
  };
  const char* sampleString = "Hello, World!";
  size_t strLength = strlen(sampleString);
  struct FlexArrayStruct* fas = malloc(sizeof(struct FlexArrayStruct) + strLength + 1);   // 动态分配内存，包括结构体本身和字符串的长度，分配的内存大小为 sizeof(struct FlexArrayStruct) （结构体除柔性数组成员外的大小）加上字符串的长度 strLength 再加1（用于字符串的终止符 \0）
  if (!fas) {
    perror("Failed to allocate memory");
    return 1;
  }
  fas->count = strLength;                                                                      // 设置具名成员的值，设置 count 成员的值为字符串的长度
  memcpy(fas->data, sampleString, strLength + 1);                                              // 复制字符串到柔性数组成员，将字符串复制到 data 柔性数组成员中
  print_purple("FlexArrayStruct Count: %d\n", fas->count);                                     // 输出结果
  print_purple("FlexArrayStruct Data: %s\n", fas->data);                                       // 输出结果，使用 fas->data 访问柔性数组成员，并输出字符串内容
  free(fas);                                                                                   // 释放内存，柔性数组成员不能作为数组元素或其他结构体的成员，初始化和赋值操作会忽略柔性数组成员，使用 sizeof 计算结构体大小时不会包含柔性数组成员的部分。要确保在访问柔性数组成员时已经正确分配了额外的存储空间，否则会导致未定义行为                         
  struct ssc { 
    int n; 
    double d[];                                        // s.d 是柔性数组元素 
  };                                                   // 当你访问灵活数组成员时，访问操作会依据分配给整个结构体对象的内存大小来解释灵活数组的大小，具体来说：灵活数组成员是在结构体中定义的一个不完整数组成员，其大小在编译时未知，当你动态分配结构体内存时，你可以指定灵活数组成员所需的实际大小，访问灵活数组的元素时，编译器假设你已经为结构体的灵活数组部分分配了足够的内存并使用这个大小来解释灵活数组的边界
  struct ssc t1 = { 0 };                               // OK：d 如同为 double d[1]，但访问是 UB，如果没有为灵活数组成员分配额外的存储空间，它会表现得像是一个具有1个元素的数组。但是，如果访问该元素或生成一个指向该元素后面位置的指针，则会导致未定义行为
  // struct s t2 = { 1, { 4.2 } };                     // 错误：初始化忽略柔性数组，只能初始化具名成员，灵活数组成员被忽略
  struct ssc *ssc1 = malloc(sizeof (struct s) + 64); // 若 sizeof (double) == 8，如同 d 为 double d[8]
  struct ssc *ssc2 = malloc(sizeof (struct s) + 40); // 若 sizeof (double) == 8，如同 d 为 double d[5]
  ssc1 = malloc(sizeof (struct s) + 10);             // 若 sizeof (double) == 8，现在如同 d 为 double d[1]
  double *dp = &(ssc1->d[0]);                          // OK，获取地址没问题，包含8个完整字节
  *dp = 42;                                            // OK，赋值没问题，包含8个完整字节
  ssc1->d[1]++;                                        // 未定义行为，不能将超出的2字节作为 double 访问
  ssc2 = malloc(sizeof (struct s) + 6);                // 同上，但访问为 UB，因为缺少两个字节作为完整的 double
  dp = &(ssc2->d[0]);                                  // OK，获取地址没问题
  *dp = 42;                                            // 未定义行为，字节数不够
  *ssc1 = *ssc2;                                       // 只复制 s.n，没有任何 s.d 的元素，除了 sizeof (struct s) 中捕获的元素，
  print_purple("s sizeof = %zu. int sizeof = %zu. double sizeof = %zu.\n", sizeof(struct s), sizeof(int), sizeof(double));  // 输出 sizeof(int) 的值 sizeof 运算符会忽略灵活数组成员，但可能会有更多的尾部填充
  // struct Invalid {
  //   struct ssc arr[10];                                  // 非法：具有灵活数组成员的结构体不能作为数组元素
  // };
  // struct AnotherInvalid {
  //   struct ssc example;                                  // 非法：具有灵活数组成员的结构体不能作为其他结构体的成员
  // };    
  struct v {                            
    union {                               // 匿名联合体  匿名联合体是没有名字的联合体类型
      struct { int i, j; };               // 匿名结构体  匿名结构体是没有名字的结构体类型
      struct { long k, l; } w;
    };
    int m;
  } v1;
  v1.i = 2;                               // 7、合法，匿名结构体的成员可以直接在外围结构体或联合体中使用，就好像它们是外围结构体或联合体的成员一样，如果外围结构体或联合体也是匿名的，那么同样的规则递归应用，这意味着更内层的匿名结构体成员也可以直接在更外层的结构体或联合体中使用
  // v1.k = 3;                            // 非法：内层结构体非匿名
  v1.w.k = 5;                             // 合法：使用w名称获取  
  struct UndefinedBehaviorExample {       // 8、具名成员是指在结构体或联合体中拥有名字的成员。它们可以直接通过成员名来访问，未定义行为意味着程序的行为不可预测，可能会导致程序运行时崩溃、产生错误结果，甚至出现安全问题
    struct {         // 匿名结构体
      int member1;   // 匿名结构体的成员
    };
    union {          // 匿名联合体
      float member2; // 匿名联合体的成员
    };
  };
  struct UndefinedBehaviorExample uexample; // 尝试访问匿名结构体和联合体的成员
  uexample.member1 = 10;                    // 这种访问方式会导致未定义行为
  uexample.member2 = 3.14f;                 // 这种访问方式会导致未定义行为
  print_purple("Member 1: %d\n", uexample.member1);
  print_purple("Member 2: %f\n", uexample.member2);  
  struct DefinedBehaviorExample {           // 定义一个包含匿名嵌套结构体和联合体，并且有具名成员的结构体
    int named_member;                       // 具名成员
    struct {                                // 匿名结构体
      int member1;                          // 匿名结构体的成员
    };
    union {                                 // 匿名联合体
      float member2;                        // 匿名联合体的成员
    };
  };
  struct DefinedBehaviorExample dexample;
  dexample.named_member = 5;                // 访问具名成员
  dexample.member1 = 10;                    // 访问匿名结构体和联合体的成员
  dexample.member2 = 3.14f;                 // 访问匿名结构体和联合体的成员
  print_purple("Named member: %d\n", dexample.named_member);
  print_purple("Member 1: %d\n", dexample.member1);
  print_purple("Member 2: %f\n", dexample.member2);
  struct y;             // 9、前置声明 struct y ，通过前向声明，可以让结构体相互引用，解决了在定义相互依赖数据结构时的困难。前向声明使得编写复杂的数据结构变得更加灵活和可行
  struct x {            // 定义 struct x，包含一个指向 struct y 的指针
    struct y *p;        // 这里 struct y 是不完整类型，只能声明指针,前向声明允许在定义结构体之前引用它。前向声明的结构体在定义之前被视为不完整类型，只能用来声明指针但不能直接操作
    // 其他成员...
  };
  struct y {            // 现在定义 struct y，包含一个指向 struct x 的指针
    struct x *q;        // 这里 struct x 是完整类型
    struct x q1;
    // 其他成员...
  };
  struct x instanceX;             // 创建结构体的实例
  struct y instanceY;             // 创建结构体的实例
  instanceX.p = &instanceY;       // 相互引用
  instanceY.q = &instanceX;       // 相互引用
  print_purple("instanceX.p: %p\n", (void*)instanceX.p);
  print_purple("instanceY.q: %p\n", (void*)instanceY.q);
  // void g(void) {
  //   struct qs;                   // 新的局部 struct qs 的前置声明它隐藏全局 struct qs 直至此块结束
  //   struct qs *p;                // 指向局部 struct qs 的指针，若无上面的前置声明，则它会指向文件作用域的 qs
  //   struct qs { char* p; };      // 局部 struct qs 的定义
  //   struct qs local_instance;    // 在这个作用域内，struct qs 是局部定义的，不是全局的 struct qs
  //   local_instance.p = "Local struct s"; // 使用局部定义的 struct qs
  //   print_purple("Local instance p: %s\n", local_instance.p);
  // }
  // g();                           // 如果在一个作用域中重新声明了一个结构体标签，它会隐藏在更高作用域中具有相同标签的结构体，直到当前作用域结束
  struct qs global_instance;
  global_instance.a = 10;           // 使用全局定义的 struct qs
  print_purple("Global instance a: %d\n", global_instance.a);
  struct Node {
    int value;
    struct Node* next;              // 10、指向同类型结构体的指针成员，此行 Node 还不是完整类型 只能是指针
  };
  struct Node node1;
  struct Node node2;
  node1.value = 1;
  node1.next = &node2;
  node2.value = 2;
  node2.next = NULL;
  print_purple("Node1 value: %d\n", node1.value);
  print_purple("Node2 value: %d\n", node1.next->value);
  struct Container {               // 11、定义一个结构体包含嵌套类型和枚举
    struct Inner {
      int x;
    } inner;
    enum { RED4, GREEN4, BLUE4 } color;
  };
  struct Container container;
  container.inner.x = 10;         // 访问嵌套结构体和枚举
  container.color = GREEN;        // 访问嵌套结构体和枚举
  print_purple("Inner x: %d\n", container.inner.x);
  print_purple("Color: %d\n", container.color);  
  int color = BLUE4;              // 直接访问枚举项（在外围作用域可见）
  print_purple("Color from enum: %d\n", color);   

  /*
  union，详细见 unions.c 文档
  联合体是由一序列的成员所组成的类型，各成员的存储重叠（与结构体相反，结构体是由一序列的成员所构成的类型，成员的存储以顺序分配）。在任一时刻，最多能在联合体中存储其一个成员的值，联合体的类型说明符与 struct 类型说明符相同，只是所用的关键词有别

  联合体声明方式语法规则 
  union 属性声明符序列(可选) 名字(可选) { 联合体声明列表 }  联合体定义：引入一个新类型 union 名字 并定义其含义
  union 属性声明符序列(可选) 名字 声明但不定义 union 名字（前置声明），在其他上下文中命名先前声明的联合体，并且不允许属性说明符序列，即属性声明符序列存在，它不能后随 
  名字 所定义的联合体的名称
  联合体声明列表	任意数量的变量声明，位域声明和静态断言声明，不允许不完整类型的成员和函数类型的成员、属性声明符序列 (C23起)可选的属性列表应用到联合体类型，若这种形式不后随（即不是前置声明）则不允许

  联合体特性、使用、初始化
  1、联合体中的所有成员共享同一块内存区域，联合体的大小至少等于其最大成员的大小。编译器可能会添加额外的尾随填充字节，以满足对齐要求
  2、指针转换 可以将指向联合体的指针转型为指向它每个成员的指针（若联合体拥有位域成员，则能转型指向联合体的指针为指向位域底层类型的指针）。类似地，指向结构体任何成员的指针都能被转型为指向整个结构体的指针
  3、类型双关 通过联合体不同成员来访问同一块内存，从而实现数据类型的转换，若用于访问内容的联合体成员不同于上次用于存储值的成员，则转译被存储值的对象表示为新类型的对象表示（这被称为类型双关），若新类型的大小大于上次写入的类型大小，则多出的字节内容是未指明的（而且可以是陷阱表示）
  4、匿名联合体 类似结构体，类型为不带名字的联合体的无名联合体成员，每个匿名联合体的成员被认为是外围结构体或联合体的成员并维持联合体布局不变。若外围结构体或联合体亦为匿名，则递归应用此规则
  5、类似结构体，若不以任何具名成员（包含经由匿名嵌套结构体或联合体获得的成员）定义联合体，则程序行为未定义 
  */
  union Data {
    int i;
    float f;
    char str[20];     //最大的字节成员
  };
  union Data data;
  data.i = 10;
  print_purple("data.i : %d\n", data.i);
  data.f = 220.5f;
  print_purple("data.f : %f\n", data.f);
  strcpy(data.str, "C Programming");
  print_purple("data.str : %s\n", data.str);
  print_purple("size of Data = %zu. size of data = %zu.\n", sizeof(union Data), sizeof(data));  

  union Exampleun { // 1、在这个联合体中，int 通常占 4 个字节，double 通常占 8 个字节，char 占 1 个字节。联合体的总大小至少是 8 个字节，因为 double 是最大的成员。编译器也可能添加一些额外的填充字节以满足对齐要求
    int i;
    double d;
    char c;
  };
  union Exampleun ex;
  union Exampleun *pex = &ex;
  int *puni = (int *)pex;                         // 2、指向联合体的指针转换为成员的指针，可以将指向联合体的指针转换为指向其任意成员的指针。这是因为联合体的所有成员共享同一块内存区域
  double *pd = (double *)pex;
  char *punc = (char *)pex;
  ex.i = 42;
  int *pxi = &ex.i;
  union Exampleun *pexi = (union Exampleun *)pi;    // 2、指向联合体成员的指针转换为指向联合体的指针，指向联合体成员的指针也可以转换为指向整个联合体的指针   
  union Exampleun1 {
    unsigned int field1 : 3;   // 一个3位的无符号整数
    unsigned int field2 : 5;   // 一个5位的无符号整数
    unsigned int field3 : 8;   // 一个8位的无符号整数
  };
  union Exampleun1 ex1;
  ex1.field1 = 5;              // 将field1设置为5（二进制：101）
  unsigned int *pField1 = (unsigned int *)&ex1;
  struct vun {                 // 4、匿名联合体的成员被视为其外围结构体或联合体的成员，可以直接访问。这种规则可以递归应用于嵌套的匿名联合体
    union { // 匿名联合体
      struct { int i, j; }; // 匿名结构体
      struct { long k, l; } w;
    };
    int m;
  } vun1;
  vun1.i = 2;      // 合法，可直接访问
  // vun1.k = 3;   // 非法：内层结构体不是匿名的
  vun1.w.k = 5;    // 合法，通过名称访问
  union Exampleun2 {          // 5、没有具名成员的联合体、联合体中包含匿名嵌套结构体或联合体，但这些结构体或联合体也不包含任何具名成员，结果会导致未定义行为
    struct {
      // 没有具名成员 结构未定义
    };
  }; 
  union Exampleun3 {
    int i;  // 具名成员
    float f;
  };

  union pad {               // 此联合体拥有尾随的 3 个填充字节
    char  c[5];             // 占据 5 字节 => char c[5] 需要 5 字节，但没有特定对齐要求
    float f;                // 占据 4 字节，隐含对齐 4 => float f 需要 4 字节，并且要求 4 字节对齐
  } pun = {.f = 1.23};      // 大小为 8 以满足 float 的对齐，联合体的大小必须满足所有成员的对齐要求和大小需求，为了满足 float 的对齐要求（通常是 4 字节），联合体的总大小必须是 float 对齐的倍数。因为 char c[5] 和 float f 共享相同的存储空间，联合体的总大小必须是 4 的倍数，并且至少需要容纳最大的成员 c[5] 的 5 字节。因此，编译器会在 char c[5] 后面添加 3 个字节的填充，使得总大小达到 8 字节，以满足 float 的对齐要求
  print_purple("size of union of char[5] and float is %zu\n", sizeof pun); // 内存对齐是指数据在内存中存储的位置需满足某种约束条件，以提高内存访问的效率。不同类型的数据可能有不同的对齐要求。例如，4字节的 float 类型通常要求4字节对齐，这意味着它的地址必须是4的倍数

  /*
  原子类型(C11)，详细见 atomics.c 文档
  原子类型语法 (C11起) _Atomic 有两种用法：用作类型说明符和用作类型限定符
  1、_Atomic (类型名) 
  用作类型说明符；这种用法定义了一个新的原子类型，其中类型名是除数组或函数外的任意类型。注意，类型名不能是另一个原子类型或带有 const、volatile、restrict 限定符的类型
  2、_Atomic 类型名 
  用作类型限定符；这种用法定义了类型名的一个原子版本。与 const、volatile 和 restrict 等其他类型限定符不同，原子类型可能有不同的大小、对齐和对象表示。原子类型可以与 const、volatile 和 restrict 等限定符混合使用
  _Atomic (类型名)：用作类型说明符，定义新的原子类型，不能带有其他限定符或嵌套其他原子类型。这是为了简化类型系统，避免复杂性，即这种用法定义了一个新的原子类型。此时，_Atomic 创建了一个新的类型，与基础类型不同。由于 _Atomic (类型名) 是创建一个全新的类型定义，所以它不能包含任何限定符（如 const、volatile、restrict），也不能嵌套另一个原子类型
  _Atomic 类型名：用作类型限定符，修饰现有类型，可以与其他限定符（如 const、volatile、restrict）一起使用。这种用法提供了更大的灵活性，即这种用法将一个已存在的类型限定为原子类型。在这种用法中，_Atomic 被视为类型限定符，就像 const、volatile 和 restrict 一样。由于它是一个限定符，可以与其他限定符一起使用

  3、头文件 <stdatomic.h> 定义了 37 个便利类型别名，从 atomic_bool 到 atomic_uintmax_t 简化了此关键词与内建及库类型的组合使用，<stdatomic.h> 提供了 37 个便利类型别名。这些别名可以让代码更简洁、更易读
  若编译器定义了宏常量 __STDC_NO_ATOMICS__，则不提供关键词 _Atomic

  解释
  4、原子类型的对象是仅有的免除数据竞争的对象；即它们可以被两个线程共时修改，或被一个修改并被另一个读取
  数据竞争（Data Race）是一种常见的并发问题，发生在两个或多个线程同时访问同一个共享变量，并且至少有一个线程在修改这个变量。数据竞争可能导致不可预测的行为和难以调试的错误，原子类型通过确保对变量的操作是不可分割的（即原子的），从而避免数据竞争。原子操作可以被看作是在内部加锁，使得一个操作在一个时间点只能由一个线程完成
  原子对象：原子对象通过原子操作避免数据竞争
  线程安全：原子操作提供了一种线程安全的方式来修改共享变量，避免了多线程访问中的数据竞争问题
  为什么原子类型可以避免数据竞争
  原子类型（Atomic Types）通过确保对变量的操作是不可分割的（即原子的），从而避免了数据竞争。具体来说，原子操作具有以下特性
  不可分割性：原子操作是不可分割的，即操作要么全部完成，要么完全不完成。不会出现部分完成的情况
  顺序一致性：原子操作保证在不同线程中对同一个原子对象的操作有一个一致的顺序。即使多个线程同时操作同一个原子对象，它们看到的操作结果也是一致的
  硬件支持：现代处理器提供了对原子操作的硬件支持，如原子加减、交换等，使得这些操作在硬件层面上也是原子的

  5、每个原子对象都拥有关联于其自身的修改顺序，即对该对象的修改的全序。若从某个线程的视角来看，对于某原子对象 M 修改的 A 发生早于同一原子对象 M 修改的 B，则在 M 修改的顺序中 A 出现早于 B
  修改顺序 每个原子对象都有一个关联的修改顺序（Modification Order），这是一种全序（Total Order），即对该对象的所有修改可以按某种线性顺序排列。这种顺序定义了某个线程视角下对该原子对象的所有修改的顺序
  修改顺序：原子对象的修改顺序是全序的，确保对原子对象的所有修改可以按某种线性顺序排列

  6、注意即使每个原子对象都有其自身的修改顺序，却并无单独的全序；不同线程可能会观测到不同原子对象有相异的修改顺序，即原子的修改顺序 每个原子对象都有其自身的“修改顺序”（modification order），这是对该对象的所有修改操作的总顺序。对于一个特定的原子对象，所有线程都能以相同的顺序观察到这些修改。但这并不意味着所有线程对不同原子对象的修改观察顺序是一致的 
  这句话的意思是，尽管每一个原子对象都有其自身的修改顺序，但并不存在一个单一的全局顺序；不同的线程可能会以不同的顺序观察到对不同原子对象的修改
  具体来说，在并发编程中，原子对象的修改是线程安全的，即对这些对象的读取和写入操作是以原子性方式进行的，不会发生数据竞争。然而，每个原子对象的修改顺序是独立的，某个原子对象的修改顺序不一定与其他原子对象的修改顺序一致。这就意味着，不同的线程在访问这些原子对象时，可能会观察到不同的修改顺序
  例如，假设有两个原子对象A和B，线程T1首先修改了A，然后修改了B，而线程T2可能首先观察到B的修改，然后观察到A的修改。这种现象是因为每个原子对象都有其独立的修改顺序，而没有一个统一的全局顺序来规定所有原子对象的修改顺序
  
  多线程编程中的一个重要概念 内存模型和一致性。在多线程环境中，即使单个原子对象的操作具有顺序一致性，不同线程可能会观察到不同的操作顺序。这是因为内存模型允许某些优化和重排序，以提高性能
  内存模型中的一致性 内存模型允许一定程度的重排序和优化，这使得不同线程可能以不同的顺序观察到操作的执行。即使 atomic_store 和 atomic_load 是原子的且在单个对象上是有序的，不同线程对不同对象的观察顺序仍可能不一致
  解决方法 如果需要确保某些操作的严格顺序，可以使用更多的同步原语
  互斥锁（Mutex）：确保临界区内的操作是顺序一致的，互斥锁（Mutex）是用于保护临界区的一种同步机制。临界区是指那些不允许多个线程同时执行的代码段。通过使用互斥锁，可以确保在同一时间只有一个线程可以进入临界区，从而保证操作的顺序一致性
  条件变量（Condition Variable）：用于线程间的复杂同步，条件变量用于线程之间的复杂同步，通常与互斥锁一起使用。条件变量允许一个线程阻塞并等待某个条件变为真，另一个线程可以发出信号以唤醒等待的线程
  内存栅栏（Memory Fences）：强制特定的操作顺序，内存栅栏（也称为内存屏障）是一种低级的同步原语，用于防止编译器和处理器对读写操作进行重排序。内存栅栏可以确保某些操作在内存中的执行顺序
  原子的修改顺序：每个原子对象都有其自身的修改顺序，所有线程对同一原子对象的修改顺序观察是一致的
  不同线程的观察顺序：不同线程可能对不同原子对象的修改顺序观察不一致，这没有单独的全序
  内存模型的影响：内存模型允许优化和重排序，使得不同线程可能以不同的顺序观察到操作  

  对于所有原子运算，保证有四种连贯，即在多线程编程中，原子操作是确保并发安全的关键。C11标准引入了原子类型和操作，这些操作保证了四种连贯性：写写连贯、读读连贯、读写连贯和写读连贯
  7、写写连贯：若原子对象 M 的修改操作 A 发生早于 M 的修改操作 B，则 M 的修改顺序中 A 出现早于 B
  8、读读连贯：若原子对象 M 的值计算 A 发生早于 M 的值计算 B，且从 M 上的副效应 X 求得 A 值，则 B 所计算得的值要么是 X 所存储的值，要么是 M 上的副效应 Y 所存储的值，其中 Y 在 M 的修改顺序中出现晚于 X
  9、读写连贯：若原子对象 M 的值计算 A 发生早于 M 上的操作 B，则从 M 上的副效应 X 求得 A 值，这里 X 在 M 的修改顺序中出现早于 B
  10、写读连贯：若在原子对象 M 上的副效应 X 发生早于 M 的值计算 B，则求值 B 从 X，或从在 M 的修改顺序中出现晚于 X 的副效应 Y 求得其值
  写写连贯性保证了在一个线程对某个原子对象进行写操作之后，该线程以及其他所有线程对该原子对象的后续写操作都能够看到先前写操作的结果。这意味着写操作不会被乱序执行
  读读连贯性保证一个线程对原子对象的读操作在另一个线程对该原子对象的读操作之前发生时，前一个读操作不得看到后一个读操作的结果
  读写连贯性保证一个线程对原子对象的读操作在另一个线程对该原子对象的写操作之前发生时，读操作不能读取到写操作之后的值
  写读连贯性保证如果一个线程对原子对象进行了写操作，而另一个线程随后进行了读操作，那么读操作要么读取到当前的写入值，要么读取到之后的某个值，而不会读取到更早的值  

  11、一些原子运算亦是同步操作：它们可以拥有附加的释放语义、获取语义，或顺序一致语义。见 memory_order ?
  在C语言中的多线程编程中，原子操作提供了一种确保并发访问数据安全的机制。不同的内存顺序（memory_order）描述了操作的同步语义以及它们在程序中的顺序。具体来说，内存顺序控制了原子操作对其他线程的可见性，以及它们在与其他内存操作的相对顺序
  memory_order_relaxed 不提供任何同步或顺序的保证。这意味着此操作只保证原子性，不提供跨线程的可见性保证，当你只需要原子操作的原子性而不关心操作的顺序时
  memory_order_acquire 获取操作，确保在当前线程中，这个操作之后的所有读写操作都不会在内存操作之前被重排序。这种语义主要用于加载操作，当你需要确保在读取一个值之后，随后读取的其他值都是最新的
  memory_order_release 释放操作，确保在当前线程中，这个操作之前的所有读写操作都不会在内存操作之后被重排序。这种语义主要用于存储操作，当你需要确保在写入一个值之前，所有的写操作都已经完成
  memory_order_acq_rel 获取-释放操作，结合了获取和释放语义。这意味着这个操作既是获取操作又是释放操作。它确保在当前线程中，这个操作之前的所有写操作在这个操作之后的所有读操作之前完成，当你在同一操作中既需要获取语义又需要释放语义时，通常用于读-改-写操作
  memory_order_seq_cst 顺序一致性操作，提供最强的同步和顺序保证。所有操作都看起来像是在单一的全局顺序中执行。它确保所有线程看到的操作顺序是一致的，当你需要最强的同步和顺序保证时  

  12、内建的自增减运算符和复合赋值运算符是拥有完全序列一致顺序（如同用 memory_order_seq_cst）的读-修改-写操作。若想要较不严格的同步语义，则可以用标准库函数替代
  内建的自增减运算符和复合赋值运算符 在C语言中，内建的自增/自减运算符（如++和--）以及复合赋值运算符（如+=和-=）在用于原子类型时，通常会具有完全序列一致的顺序（memory_order_seq_cst）的读-修改-写操作
  完全序列一致顺序（memory_order_seq_cst）memory_order_seq_cst（Sequentially Consistent Order）是C11标准中的一个内存顺序模型。它确保所有操作在所有线程中以全局一致的顺序进行，这意味着所有线程看到的操作顺序都是相同的。这是最严格的内存序列模型，确保了最强的同步语义，具体来说，对于原子变量的内建自增/自减以及复合赋值操作，使用memory_order_seq_cst意味着这些操作不仅是原子的，而且它们的执行顺序在程序的所有线程中是一致的
  较不严格的同步语义 在某些情况下，完全序列一致顺序可能不必要，并且可能会导致性能开销。如果你希望使用较不严格的同步语义，可以使用标准库函数来替换默认的内建运算符，并指定更松散的内存顺序约束，C标准库提供了一些原子操作函数（如atomic_fetch_add、atomic_fetch_sub等），允许你指定内存顺序模型，如memory_order_relaxed、memory_order_acquire、memory_order_release等  
  
  13、原子属性仅对左值表达式有意义。左值到右值转换（模仿从原子区域到 CPU 寄存器的内存读取）会把原子性及其他限定符剥去
  原子属性仅对左值表达式有意义 左值（lvalue）是指可以出现在赋值运算符左侧的表达式，它代表一个存储位置。原子类型（如atomic_int）的原子属性是指这些类型的变量在多线程环境中执行原子操作（如读、写、修改时不会被其他线程干扰）的能力
  原子属性仅对左值表达式有意义，这意味着对原子变量的原子操作必须通过左值来进行。例如，对一个原子变量执行原子读、写或修改操作时，该变量必须是一个左值
  左值到右值转换 在C和C++中，右值（rvalue）是指可以出现在赋值运算符右侧的表达式，它代表某个值（而不是存储位置）。当一个左值转换为右值时，它的值会被读取，并且该值可以被用来进行计算或赋值给其他变量
  左值到右值转换（即从原子区域到CPU寄存器的内存读取）会把原子性及其他限定符剥去。意思是，当你读取一个原子变量的值并将其存储在一个非原子变量（通常是一个CPU寄存器）中时，原子变量的原子性属性就不再适用了
  原子属性仅对左值表达式有意义：原子操作必须通过左值（存储位置）来进行
  左值到右值转换：当将一个原子变量的值读取到一个普通变量（或右值）中时，原子性属性被剥去，该普通变量就不再具备原子性  
  
  14、本节未完成原因：更多和 memory_order 及原子库页面的综述互动

  原子类型注解
  15、访问原子结构体/联合体的成员是未定义行为，在C11标准中，如果你定义了一个包含原子类型成员的结构体或联合体，直接访问这些原子成员是未定义行为。这是因为标准并未定义如何保证这些成员的原子性
  16、sig_atomic_t 不提供线程间同步或内存定序，仅提供原子性，sig_atomic_t 是C标准库定义的一个类型，通常用于信号处理程序中，以确保对变量的访问是原子的。然而，sig_atomic_t 并不提供线程间的同步或内存序列保证，只提供对信号处理上下文中变量访问的基本原子性
  17、volatile 类型不提供线程间同步、内存定序或原子性，在C和C++中，volatile 关键字告诉编译器不要对使用该变量的代码进行优化，因为该变量可能在程序外部（如硬件或信号处理程序）被修改。然而，volatile 并不提供线程间同步、内存序列保证或原子性
  18、推荐实现确保对于每个可能的类型 T，C 中 _Atomic(T) 的表示与 C++ 中 std::atomic<T> 的相同，为了保证C和C++之间的兼容性，推荐实现保证C中的 _Atomic(T) 与C++中的 std::atomic<T> 表示相同。这确保了原子性和内存顺序机制在两种语言中是一致的  
  */
  print_purple("atomic type\n");  
  _Atomic (int) atomic_int_var;                     // 1、在这个示例中，atomic_int_var 是一个原子的 int 类型变量，通过 _Atomic (int) 语法定义
  atomic_int_var = 0;
  atomic_fetch_add(&atomic_int_var, 1);             // 原子地增加 1
  // _Atomic (const int) atomic_const_int_var;      // 不允许，const 不能用于类型说明符
  // _Atomic (_Atomic (int)) nested_atomic_int_var; // 不允许，不能嵌套原子类型
  atomic_int atomic_counter;                 // 2、定义一个原子的 int 类型变量，在这个示例中，atomic_counter 是一个原子的 int 类型变量，通过 atomic_int 宏定义。atomic_int 是 _Atomic int 的别名 
  atomic_counter = 0;                 
  atomic_fetch_add(&atomic_counter, 1);      // 原子地增加 1
  _Atomic const int atomic_const_int;        // 2、定义一个原子的、const常量的 int 类型变量，在这个示例中，atomic_const_int 是一个原子的、常量的 int 类型变量。因为它是常量，所以不能修改它的值
  // atomic_const_int                        // 是常量，不能修改它的值
  // atomic_fetch_add(&atomic_const_int, 1); // 这将导致编译错误
  _Atomic const int * pa1;                    // p1 是指向 atomic const int 的指针
  const atomic_int * pa2;                     // 同上 p2 是指向 atomic const int 的指针
  const _Atomic(int) * pa3;                   // 同上 p3 是指向 atomic const int 的指针         
  atomic_int atomic_counter1;                // 3、声明一个原子的 int 变量
  atomic_bool flag;                          // 声明一个原子的 bool 变量
  atomic_store(&atomic_counter, 0);          // 初始化原子变量
  atomic_store(&flag, false);                // 初始化原子布尔变量  
  atomic_fetch_add(&atomic_counter, 1);      // 原子地增加 1
  bool current_flag = atomic_load(&flag);    // 原子地加载布尔值
  print_purple("current_flag = %d.\n", current_flag);  

  /*
  位域 Bit-fields
  声明带有明确宽度的成员，按位数计。相邻的位域成员可能被打包，共享和分散到各个单独的字节
  位域是C语言中的一种特殊结构体成员，用于在结构体或联合体中以位级别（bit level）来定义数据成员。它的使用场景主要是为了节省存储空间或者与硬件寄存器映射的时候，硬件寄存器：位域常用于直接映射硬件寄存器，方便操作特定位，存储优化：通过位域可以精确控制每个成员占用的位数，减少空间浪费
  
  位域声明，是使用下列 声明符的结构体或联合体的 成员声明
  标识符(可选) : 宽度		
  标识符 正在声明的位域名称。名称是可选的：无名位域引入一个指定的填充位数
  宽度 一个拥有大于或等于零，且小于或等于底层类型位数的整数常量表达式。大于零时，此为此位域将占据的位数。零值仅允许用于无名位域，并拥有特殊含义：它指定结构体定义中的下个位域会从分配单元边界开始
  
  解释
  位域（在 C99 之前）只能有以下三种类型之一，（从 C99 开始到 C23）有四种类型（可能带有 const 或 volatile 限定符）
  unsigned int，用于无符号位域（unsigned int b:3; 的范围是 0..7 ）
  signed int，用于有符号位域（signed int b:3; 的范围是 -4..3 ）
  int 用于具有实现定义的有符号性的位域（注意，这与关键字 int 在其他任何地方的含义不同，在其他地方它的意思是 有符号整数）。例如，int b:3;  可能具有值的范围为 -4..3 或者 0..7
  _Bool 类型，用于单位比特位域（例如 bool x:1;），取值范围为 0 到 1，并且与其进行的隐式转换遵循布尔转换规则(C99 起)
  位精确整数类型（例如，_BitInt (5):4; 范围为 -8..7 而 unsigned _BitInt (5):4; 范围为 0..15））(C23 起)
  其他实现定义的类型可能是可接受的。位域是否可以具有原子类型也是由实现定义的。（自 C11 起）位域中的位数（宽度）设定了它可以容纳的值的范围

  允许将多个相邻位域打包在一起（通常如此）
  struct S {
    // 通常将占用 4 字节：
    // 5 位： b1 的值
    // 11 位：未使用
    // 6 位： b2 的值
    // 2 位： b3 的值
    // 8 位：未使用
    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;
  };

  拥有零 宽度 的特殊无名位域打破填充：它指定下个位域在始于下个分配单元的起点
  struct S {
    // 通常将占用 8 字节
    // 5 位： b1 的值
    // 27 位：未使用
    // 6 位： b2 的值
    // 15 位： b3 的值
    // 11 位：未使用
    unsigned b1 : 5;
    unsigned :0; // 开始新的 unsigned int
    unsigned b2 : 6;
    unsigned b3 : 15;
  };
  因为位域不必在字节的起点开始，故不能取位域的地址。不可能有指向位域的指针。不能对位域使用 sizeof 和 _Alignas (C11 起)，但可以获取包含这些位域的分配单元的地址比如 unsigned 

  注解
  在位域上调用 offsetof 这种用法导致未定义行为
  offsetof是一个宏，用于计算结构体成员相对于结构体起始位置的偏移量。定义在stddef.h中，通常用于获取某个成员在结构体中的偏移量。但是，当试图使用offsetof宏来获取位域成员的偏移量时，会导致未定义行为
  内存布局和对齐：位域的内存布局和对齐方式在不同的编译器和平台上是不同的。位域成员可能会跨越字节边界或者被填充位（padding bits）分隔。这种不确定性使得位域成员的确切位置难以确定
  标准未定义性：C和C++标准没有定义位域成员在内存中的具体布局和对齐方式。因此，使用offsetof宏来获取位域成员的偏移量，会因为其未定义的存储特性而导致不可预测的结果

  保有位域的分配单元的对齐 这种位域的属性未指定
  在位域的背景下，所谓的“分配单元”通常指的是存储位域的基本内存单元（如字节、整型等）。位域的分配单元的对齐方式未指定
  平台依赖：不同的硬件平台和编译器可能会对位域成员进行不同的对齐处理。有的编译器可能会对位域进行字节对齐，有的可能会进行更复杂的对齐方式（如按整型对齐）
  无标准规定：既然C和C++标准没有明确规定位域的对齐属性，编译器有权自行决定如何处理位域的对齐。这会导致跨平台或跨编译器的代码在处理位域时产生不同的行为，增加了代码的不确定性和潜在的bug

  位域的下列属性为实现定义
  int 类型的位域被当做有符号或无符号，即在 C 中，如果你声明一个 int 类型的位域，编译器可以选择将它视为有符号或无符号。这取决于具体的编译器实现
  是否容许除 int、signed int、unsigned int、_Bool(C99 起) 和（可能 unsigned 的）_BitInt(N)(C23 起) 类型的位域，即按照规范，标准位域类型为 int、signed int、unsigned int、_Bool（从 C99 起）和 _BitInt(N)（从 C23 起）。是否允许其他类型的位域取决于编译器实现
  是否容许原子类型的位域(C11 起)，即 C11 引入了原子类型，但是否允许这些原子类型用作位域也是由编译器实现决定的
  位域是否能越过分配单元边界，即一些编译器可能强制每个位域必须完全包含在一个单元内，而另一些编译器可能允许位域跨越单元边界
  分配单元内位域的顺序（一些平台上位域从左往右打包，其他平台上是从右往左），即不同平台可能会以不同的方式存储位域。一些平台从左到右打包位域，另一些平台从右到左

  尽管 _Bool 的对象表示的位数至少为CHAR_BIT，_Bool类型位域的 宽度 不能大于1 (C99起)，即尽管 _Bool 类型的对象表示至少需要 CHAR_BIT 位（通常是 8 位），但在位域中，_Bool 类型的宽度不能超过 1 位
  C++ 编程语言中，位域的宽度能超出底层类型，并且 int 类型的位域始终为有符号，即在 C++ 中，位域宽度可以超过其底层类型的大小，且 int 类型的位域总是被视为有符号的
  */
  struct Examplebit {
    unsigned int a : 3;  // `a` 占用3位
    unsigned int b : 5;  // `b` 占用5位，可能与 `a` 位域共享同一个字节或存储单元
    unsigned int : 0;    // 强制下一位域（`c`）从新存储单元开始
    unsigned int c : 8;  // `c` 占用8位，从新存储单元开始
  };                     // a 和 b 可能被打包在同一个字节或存储单元中，具体取决于系统架构和编译器实现，由于 unsigned int : 0，c 将从新的存储单元的开始位置开始
  struct Sbit {
    // 三位无符号位域，
    // 允许值为 0..7
    unsigned int b : 3;
  };
  struct Sbit sbit = {7};
  ++sbit.b;                               // 无符号溢出
  print_purple("sbit.b = %d\n", sbit.b);  // 输出： 0
  struct Sbt1 {
    // 通常将占用 4 字节：
    // 5 位： b1 的值
    // 11 位：未使用
    // 6 位： b2 的值
    // 2 位： b3 的值
    // 8 位：未使用
    unsigned b1 : 5, : 11, b2 : 6, b3 : 2;
  };
  print_purple("Sbt1 sizeof = %zu\n",sizeof(struct Sbt1)); // 通常打印 4
  struct Sbt2 {
    // 通常将占用 8 字节
    // 5 位： b1 的值
    // 27 位：未使用
    // 6 位： b2 的值
    // 15 位： b3 的值
    // 11 位：未使用
    unsigned b1 : 5;
    unsigned :0; // 开始新的 unsigned int
    unsigned b2 : 6;
    unsigned b3 : 15;
  };
  print_purple("Sbt2 sizeof = %zu\n", sizeof(struct Sbt2)); // 通常打印 8

  /*
  const 类型限定符 
  在 C 类型系统中每一个独立的类型，都有该类型的几个限定版本，对应 const、volatile 及对于指向对象指针的 restrict 限定符中的一个、两个或全部三个。本节描述 const 限定符的效果
  
  1、用 const 限定类型声明的对象可能会被编译器放置在只读内存中，并且如果在程序中从未获取过 const 对象的地址，那么它可能根本不会被存储，任何尝试修改类型为 const 限定的对象的行为都会导致未定义的行为
  
  2、const 语义仅适用于左值表达式；当在不需要左值的上下文中使用常量左值表达式时，其 const 限定符会丢失（请注意，如果存在 volatile 限定符，则不会丢失）
  左值（lvalue）的概念：左值是一个表示数据对象的表达式，它具有确定的内存地址，并且在程序执行过程中可以出现在赋值运算符的左边（当然，不是所有左值都能合法地放在赋值运算符左边，比如被 const 修饰的左值就不行）。例如，变量名就是常见的左值，像 int num = 10; 这里的 num 就是一个左值，它对应内存中存储 num 值的位置，可以通过 num 去获取或者修改这个位置存储的值（如果没有其他限制条件的话）
  const 语义与左值：当我们用 const 修饰一个变量，比如 const int n = 5;，此时 n 就是一个常量左值表达式。const 的语义作用在这个左值上，意味着这个左值所代表的数据对象（也就是 n 对应的内存存储的值）在程序中是不应该被修改的，编译器会基于这个限定来进行一些检查和优化（虽然通过一些不正当手段还是可能破坏这个限定，如前面提到的利用指针强制类型转换去修改 const 变量，但这属于未定义行为）。所以说 const 语义是针对左值表达式来体现的，它限定了这个左值所关联的对象的可修改性
  不需要左值的上下文举例：比如在函数调用传值的场景中，如果函数参数是按值传递（不是传递指针或者引用），并且参数类型是一个 const 限定的基本类型。例如有函数 void printValue(const int x) { printf("%d\n", x); }，在调用 printValue(n);（假设前面定义了 const int n = 5;）时，n 这个常量左值表达式的值会被拷贝一份传递给函数 printValue 里的形参 x。在这里，函数内部只是使用 x 的值去打印，并不需要把 x 当作一个能修改的左值（实际上也不能修改，因为有 const 修饰），此时对于这个形参 x 所处的这个 “使用其值” 的上下文（而不是把它当作可修改的对象的上下文）来说，它的 const 限定符在某种意义上 “丢失” 了作用。也就是说在函数内部的代码生成等处理中，编译器更多地只是把它当作一个普通的值来处理，只要保证不会出现对它进行赋值等修改操作就行，不会像对待真正要维持常量性的左值那样严格限制所有相关的代码生成情况
  volatile 限定符的作用：volatile 主要用于告诉编译器，被它修饰的变量可能会在程序执行过程中被意想不到的因素（比如硬件中断、多线程并发访问等情况）修改，所以编译器不能对这个变量进行常规的优化（比如缓存其值到寄存器等可能导致看不到外部对其修改的优化行为），每次使用这个变量时都要从内存中重新读取其值
  与 const 结合时的情况：当一个变量同时被 const 和 volatile 修饰，例如 volatile const int flag = 0;，即使在一些看似不需要左值的上下文中，它的 const 限定符也不会丢失。这是因为 volatile 强调了这个变量的特殊性，其值随时可能被外部改变，所以编译器始终要把它当作一个具有特殊性质（既不能随意修改它 —— 因为有 const，又要时刻关注它的值可能变化 —— 因为有 volatile）的左值来对待，不管在何种使用场景下，都会严格遵循 const 和 volatile 的语义要求来生成相应的代码，不会出现因为上下文好像不需要左值特性就忽略 const 限定的情况

  const 对象
  3、指定具有常量限定类型 const 的对象的左值表达式，以及指定具有至少一个常量限定类型成员（包括递归包含的聚合体或联合体的成员）的结构体或联合体类型对象的左值表达式，不是可修改的左值。特别是，它们不可赋值
  针对基本类型的 const 左值 对于像 const int n = 10; 这样简单的情况，n 是一个具有常量限定类型（const int）的左值表达式。根据这条规则，它不是可修改的左值，意味着像 n = 20; 这样的赋值操作是非法的，编译器会报错。因为 const 明确限定了这个左值所代表的对象（也就是 n 对应的那个整数存储的值）不能被改变，它在整个程序的正常执行流程中应该始终保持初始设定的常量值
  针对结构体或联合体中的 const 成员 假设有如下结构体定义 struct Point { const int x; int y; }; 如果定义了一个结构体变量 struct Point p = {10, 20};，那么 p.x 就是一个指定具有常量限定类型成员（这里 x 是 const int 类型）的结构体类型对象的左值表达式。按照规则，p.x 是不可修改的左值，像 p.x = 30; 这样的赋值操作就是不合法的，编译器会检测出这违反了 const 的语义限定，阻止这样的代码通过编译
  对于联合体也是类似的道理 union Data { const int num; char str[10]; }; 定义 union Data d; 后，d.num 作为指定了常量限定类型成员的联合体对象的左值表达式，同样不可以被赋值修改，像 d.num = 5; 这种操作是不符合语言规范的，会被编译器认定为错误操作
  递归包含情况 假如存在结构体嵌套结构体，并且内层结构体有 const 限定的成员，同样不可修改，编译器会依据 const 的语义规则禁止这样的代码编译通过

  const 结构体联合体
  4、常量限定的结构或联合类型的成员会获得其所属类型的限定如 const（无论是使用 “.” 运算符还是 “->” 运算符访问时）
  
  const 数组
  5、若以 const 类型限定符声明数组类型（通过使用 typedef），则数组类型无 const 限定，但其元素类型有(C23前)，但(C23起) 始终认为数组类型与其元素类型同等地拥有 const 限定
  在 C23 之前，通过 typedef 使用 const 来限定数组时，const 的限定作用主要体现在数组元素层面，保证元素不可修改，但并没有对数组整体的可赋值等操作（从类型层面当作一个不可变的实体）进行限定，这和很多人直观上认为的整个数组都被 const 修饰的理解是不太一样的，容易产生混淆，也可能导致一些代码出现不符合预期的行为（如果程序员错误地以为数组整体不可变）
  C23 标准下让数组类型和其元素类型在 const 限定方面的处理更加统一、直观，减少了因之前标准下两者限定不一致而可能导致的误解和编程错误，使代码中对于 const 修饰数组情况的行为更符合程序员通常期望的那种 “整个数组都不可变” 的语义理解
  实际编程中，如果代码要在不同 C 语言标准的环境下编译运行，就需要特别留意这种关于数组和 const 限定相关规则的变化，避免出现兼容性问题

  const 函数
  6、若以 const 类型限定符声明函数类型（通过使用 typedef），则行为未定义，typedef 常用于给已有的数据类型定义一个新的别名，方便代码书写和增强可读性等。例如可以用 typedef 给函数指针类型定义别名，像这样 typedef int (*FuncPtr)(int);，如果试图使用 const 来限定函数类型本身（通过 typedef 操作），这在 C 语言标准中是未定义行为。例如，下面这样的代码（虽然不符合标准规范，但展示下错误示例）typedef int const FuncType(const int);  
  函数在 C 语言里有其自身特殊的调用机制、存储方式以及语义规则等。函数本身不是像普通变量那样可以简单地用 const 去限定其整体不可变，因为函数调用涉及到执行一段代码逻辑、参数传递、栈帧的操作等复杂过程。C 语言标准并没有明确规定用 const 去限定函数类型该如何处理，所以不同的编译器面对这样的情况可能会有不同的处理方式，甚至可能直接报错，这就导致了行为的不可预测性，也就是所谓的未定义行为
  7、函数声明中，关键词 const 可出现在用于声明函数形参的数组类型的方括号内。它限定数组类型所变换到的指针类型，
  在 C 语言中，当函数的形参声明为数组形式时，比如 void func(int arr[5])，实际上在函数调用传递参数时，数组会自动退化为指向其首元素的指针，即上述函数声明等同于 void func(int *arr)。这是 C 语言的一个重要特性，为了方便函数处理数组数据
  两条声明声明相同函数 void f(double x[const], const double y[const]); 退化成指针 void f(double * const x, const double * const y);

  const 复合字面量
  8、常量限定的复合字面量不一定指定不同的对象；它们可能与其他复合字面量以及碰巧具有相同或重叠表示的字符串字面量共享存储
  复合字面量是一种可以创建匿名对象（没有显式命名的对象）的语法结构，当使用 const 对复合字面量进行限定的时候，它有一些特殊的存储特性
  对于带有 const 修饰的复合字面量，编译器在处理时，出于存储优化等方面的考虑，有可能会把它们在内存中的存储进行重叠安排（只要符合相应规则，不影响程序语义的正确性），而不是一定为每个这样的复合字面量都分配完全独立、不同的内存区域，而且它们还可能和字符串字面量在存储上有重叠情况（因为字符串字面量本身也是一种不可修改的常量性质的数据，存储在只读的内存区域，和 const 限定的复合字面量在不可变这点上有相似性）
  这种重叠存储情况是编译器实现层面基于标准允许的优化可能带来的结果，不同的编译器可能有不同的表现，在实际编写代码时不能依赖这种不确定的、依赖编译器行为的情况来确保程序逻辑的绝对正确性，除非是非常明确知晓并且在特定、可控的环境下利用这种特性

  const 指针
  9、指向非 const 类型的指针能隐式转换成指向同一或兼容类型的 const 限定版本的指针。需要转型表达式进行逆向转换
  注意 指向指向 T 指针的指针不可转换为指向指向 const T 指针的指针；对于要兼容的二个类型，其限定必须等同，即 指向char*的指针 不能转为指向const char*的指针

  const 注解 在 C 中不是常量表达式，在 C++ 中为常量表达式
  10、C 从 C++ 中采纳了 “const” 限定符，但是与 C++ 不同，在 C 中具有 const 限定类型的表达式不是常量表达式；它们不能用作 case 标签，也不能用于初始化静态和线程存储持续时间对象、枚举常量或位域大小。当它们用作数组大小时，结果数组是可变长度数组 VLA
  在早期的 C 语言中并没有 const 这个关键字来专门限定常量，后来从 C++ 引入了 const 限定符。在 C++ 中，const 有着比较明确且丰富的语义用于定义常量，比如用 const 修饰的变量一旦初始化后其值就不能被改变，并且在很多场景下 const 修饰的表达式可以当作真正的常量表达式来使用。而 C 语言虽然接纳了 const 限定符，但是对它的处理和 C++ 有着关键的区别
  不是常量表达式：在 C 语言里，即使一个表达式被 const 限定了，它本质上仍然只是一个具有只读属性的变量（在内存中有对应的存储单元，和普通变量类似只是不能修改它的值），而不是像在 C++ 中那样完全等同于常量表达式 
  不可用作 case 标号：在 switch 语句中，case 后面跟的必须是常量表达式，用于和 switch 表达式的值进行匹配判断。在 C 语言中，由于 const 限定的表达式不是常量表达式
  不能用于初始化静态和线程存储期对象：静态存储期对象是指那些在程序整个生命周期内都存在的对象，例如定义在所有函数外部的全局变量，或者用 static 关键字修饰的局部变量等。在 C 语言中，初始化这类对象要求使用常量表达式，而 const 限定的表达式不符合要求
  不能用作枚举项：枚举类型中每个枚举项本质上也相当于是一个常量，在 C 语言里，const 限定的表达式没办法充当枚举项
  不能用于位域大小：在结构体中定义位域时，用于指定位域宽度的数值必须是常量表达式。同样因为 const 限定的表达式在 C 语言中不算常量表达式，所以不能用于这个用途
  当在 C 语言中把 const 限定的表达式用作数组大小时，它会生成可变长数组（Variable Length Array，简称 VLA）。可变长数组是 C99 标准引入的特性，它允许数组的大小在运行时根据实际情况确定（只要符合一定的内存等条件限制）
  */
  const int nct = 1;      // 1、const 限定类型的对象
  // nct = 2;             // 不可修改，首先，定义了一个 const int 类型的变量 n 并初始化为 1。const 关键字修饰意味着这个变量的值在正常情况下是不应该被修改的，它承诺在程序执行期间保持常量性，编译器会基于这个假设做一些优化处理，并且从语义层面阻止程序员去直接修改它的值
  int* pct = (int*)&nct;  // 声明了一个 int* 类型的指针 p，并通过强制类型转换将 n 的地址赋值给 p。这里的强制类型转换其实是一种绕过 const 限定的危险操作，因为从语言设计意图来讲，不应该通过这样的指针去修改 const 变量的值
  *pct = 2;               // 未定义行为，这块本应内存不可修改，然后执行 *p = 2，试图通过指针 p 去修改 n 的值。在 C 语言标准中，这样去修改一个 const 限定的对象的值属于未定义行为（Undefined Behavior），这意味着编译器可以自由选择如何处理这种情况，不同的编译器实现、不同的编译选项（比如是否开启优化）都可能导致截然不同的结果
  print_purple("cnt = %d, cnt address = %p\n", nct, &nct); 
  print_purple("pct = %d, pct value = %p\n", *pct, pct);
  const int nct1 = 1;     // 3、const 类型对象
  // nct1 = 2;            // 错误： nct1 的类型为 const 限定
  int xct = 2;            // 未限定类型的对象
  const int* pxct = &xct; // const 类型对象
  // *pxct = 3;           // 错误：左值 *pxct 的类型为 const 限定 
  struct {int a; const int b; } s1st = {.b=1}, s2st = {.b=2};
  // s1st = s2st;         // 错误：s1 的类型无限定，但它有 const 成员
  struct s4st { int i; const int ci; } cs5;      // 4、cs5.i 的类型为 int，cs5.ci 的类型为 const int
  const struct s4st cs6;                         // cs6.i 和 cs6.ci 的类型都是 const int
  typedef int Aarr[2][3];                        // 5、定义了一个名为Aarr的类型别名，表示一个二维数组类型，该二维数组有 2 行 3 列，元素类型为int
  const Aarr arrt = { {4, 5, 6}, {7, 8, 9} };    // const 限定了 arrt 数组中的元素不能被修改。对于这个二维数组，任何试图修改其元素值的操作都是非法的
  // arrt[0][0] = 10;                            // 非法操作，因为 arrt 是 const 限定的，不能修改其元素
  int* prti = arrt[0];                           // ？a[0] 拥有 const int* 类型，Initializing 'int *' with an expression of type 'const int[3]' discards qualifiers
  void* unqual_p = arrt;                         // ？C23 前 OK ； C23 起错误 // 注： clang 即使在 C89-C17 模式也应用 C++/C23 中的规则 Initializing 'void *' with an expression of type 'const Aarr' (aka 'const int[2][3]') discards qualifiers
  // typedef const int ArrayType[5];             // 通过typedef定义了一个新的数组类型别名，元素是const int类型
  // ArrayType arrt3;
  // void *unqual_ptr = arrt3;                   // 可以将一个ArrayType类型的数组赋值给另一个同类型数组，因为数组类型本身未被const限定，在C23中，这会被视为错误，因为数组类型本身现在被const限定了，不能随意赋值
  // arrt3[0] = 10;                              // 错误，试图修改const int类型的元素，违反了const语义
  typedef int (*FuncPtr)(int);                   // 6、定义了一个名为FuncPtr的函数指针类型别名，指向的函数参数为int，返回值为int
  typedef int const FuncType(const int);         // 试图用const限定函数类型，这是错误的，行为未定义
  void fn1(double x[const], const double y[const]);   // 7、退化成指针 void fn2(double * const x, const double * const y);
  void fn2(double * const x, const double * const y); // x 是一个指向 double 类型的 const 指针，这意味着指针 x 本身不能被修改，不能再指向其他地址，但它指向的值可以被修改
  void fn3(double x[], const double y[]);             // y 的元素不能被修改，声明表示数组中的元素是常量，不能被修改
  void fn4(double *x, const double *y);               // y 的元素不能被修改，此指针不能修改它所指向的double类型的值，但指针本身可以指向不同的地址
  const int* pcst1 = (const int[]){1, 2, 3};          // 8、通过复合字面量 (const int[]){1, 2, 3} 创建了一个匿名的 const int 类型的数组（元素为 1、2、3），然后定义了一个指向 const int 的指针 p1 指向这个匿名数组的首元素
  const int* pcst2 = (const int[]){2, 3, 4};          // pcst2 的值可等于 pcst1+1，第二行代码里，同样用复合字面量 (const int[]){2, 3, 4} 创建了另一个匿名的 const int 类型数组（元素为 2、3、4），并让指针 p2 指向它。这里注释提到 p2 的值可等于 p1 + 1，意思是由于编译器对这些 const 限定的复合字面量存储处理的灵活性，有可能在内存布局上，后面这个匿名数组 (const int[]){2, 3, 4} 的起始地址刚好和前一个匿名数组 (const int[]){1, 2, 3} 的第二个元素地址是重合的（虽然这不是必然情况，取决于编译器的实现，但标准允许这种可能的存储优化存在），所以从语法概念上来说，就好像 p2 的值等同于 p1 + 1 一样，也就是两个复合字面量所代表的数组在内存中存在了重叠表示的情况
  _Bool bl = "foobar" + 3 == (const char[]){"bar"};   // bl 的值可为 1，"foobar" 是一个字符串字面量，在 C 语言中它存储在只读的内存区域，并且它本质上可以看作是一个 const char 类型的数组（因为其内容不可修改）。表达式 "foobar" + 3 是对这个字符串字面量做指针运算，它得到的是指向该字符串中字符 'b' 的指针（因为跳过了前面 3 个字符）
  int* ptr1 = 0;                                      // 9、指向非 const 类型的指针能隐式转换成指向同一或兼容类型的 const 限定版本的指针。逆向转换需要转型表达式处理
  const int* cptr1 = ptr1;                            // OK：添加限定符（int 到 const int）
  ptr1 = cptr1;                                       // 错误：舍弃限定符（const int 到 int），Assigning to 'int *' from 'const int *' discards qualifiers
  ptr1 = (int*)cptr1;                                 // OK：转型
  char *ptr2 = 0;
  const char **cpptr2 = &ptr2;                        // const作用域 **cpptr2  错误：char* 与 const char* 不是兼容类型，Initializing 'const char **' with an expression of type 'char **' discards qualifiers in nested pointer types
  char * const *pcptr2 = &ptr2;                       // const作用域 *pcptr2 OK：添加限定符（char* 到 char *const）
  char ** const ppctr2 = &ptr2;                       // const作用域 ppctr2
  const int num = 5;                                  // 10、// 在C++中，下面这种用法是合法的，因为const int类型的num可以当作常量表达式，但在C语言中是非法的，因为C不认为num是常量表达式
  int arrnum[num];
  const int choice = 2;
  switch (choice) {
    case choice:                                      // 在C语言中，这是非法的，因为choice虽然被const限定，但不是常量表达式
      // do something
      break;
    default:
      break;
  }
  const int global_const = 10;
  static int static_variable = global_const;          // 下面是非法的，试图用const限定的global_const去初始化静态存储期的变量，在C中不行
  const int enum_value = 3;
  enum Color {
    REDC = enum_value,                                // 在C语言中，这是非法的，不能用const限定的enum_value作为枚举项
    GREENC
  };
  const int bit_width = 4;
  struct BitFieldStruct {
    unsigned int field : bit_width;                   // 在C语言中，这是非法的，不能用const限定的bit_width作为位域大小
  };
  int size = 10;
  const int const_size = size;
  int arrcval[const_size];                            // 这里定义了一个可变长数组，因为使用了const限定的const_size作为数组大小，在C语言中会这样处理

  /*
  volatile 类型限定符
  C 类型系统中的每个单独类型都有该类型的多个限定版本，对应于 const、volatile 中的一个、两个或全部三个，对于指向对象类型的指针，restrict 限定符。本节介绍 volatile 限定符的效果
  关于 volatile 限定符的基本作用 在 C 和 C++ 语言中，volatile 是一个类型限定符，它主要用于告诉编译器，被它修饰的对象（通常是变量等左值表达式所代表的对象）具有一些特殊的、易变的性质，其值可能会在程序控制流之外被改变，比如可能被硬件（像外部设备寄存器等情况）或者其他并发执行的线程（在多线程环境下）修改
  在 C 或 C++ 中，volatile 关键字被用来防止编译器对其修饰的变量进行优化，从而确保程序在每次访问该变量时（无论是读取还是写入）都直接进行内存操作。这对于某些硬件寄存器或多线程编程中特殊的内存位置是非常重要的

  1、通过 volatile 限定类型的左值表达式进行的每次访问（读取和写入）都被视为用于优化的可观察副作用，并严格根据抽象机器的规则进行评估（即，所有写入都在下一个序列点之前的某个时间完成）。这意味着在单个执行线程中，无法相对于另一个可见的副作用（由 sequence point 与 volatile 访问分开）优化或重新排序 volatile 访问
  可观察的副作用：对 volatile 变量的每一次访问（无论是读取还是写入）都被视为一个可观察的副作用。这意味着这些访问不会被编译器优化掉，因为它们被认为是对程序行为有实际影响的操作
  严格的评估顺序：根据抽象机器（即标准规定的行为模型）的规则，所有对 volatile 变量的写入操作必须在下一个序列点（sequence point）之前完成。换句话说，编译器不能随意重新排序这些操作
  单线程中的顺序保证：在单个线程的执行过程中，volatile 变量的访问顺序不能被重新排序到另一个可见的副作用之前或之后，除非有明确的序列点将它们分开
  
  访问和优化：volatile 修饰的变量在每次访问时都被视为有可观察的副作用，这意味着编译器不应该对这些访问进行优化（如缓存，寄存器替换等），确保每次访问都是直接从内存读取或写入
  序列点：序列点是 C/C++ 中定义的一个概念，表示在某些关键位置，所有的副作用（包括修改和读取）都应该在下一步之前完成。通常来说，一个序列点确保前面的所有操作都完成，后面的操作才开始
  单线程环境中的顺序保证：在单线程环境下，每个 volatile 访问（读取或写入）都会严格按程序中定义的顺序执行，而不会被编译器重新排序

  2、将 非 volatile 值强制转换为 volatile 类型不起作用。要使用 volatile 语义访问非 volatile 对象，必须将其地址强制转换为指向 volatile 的指针，然后必须通过该指针进行访问
  如果你有一个非 volatile 的变量，你不能简单地通过类型转换将其转换成 volatile 类型来获得 volatile 的语义。这是因为 volatile 的语义不仅仅涉及到变量的类型，还涉及到编译器对该变量的访问处理方式，正确的方法是通过一个指向 volatile 的指针来访问这个变量，编译器会知道对该变量的访问需要按照 volatile 的语义进行处理

  3、任何通过 非 volatile 左值读取或写入其类型符合 volatile 条件的对象的行为都会导致 undefined 行为
  如果一个对象被声明为 volatile，但是你通过一个非 volatile 的左值（变量或指针）来访问它，编译器可能会对这种访问进行优化，结果可能会导致未定义行为。未定义行为意味着程序的行为无法预测，可能会导致程序崩溃或其他不可预见的问题

  volatile 限定结构体联合体
  4、volatile 限定结构或联合类型的成员将获得其所属类型的限定（使用 . 运算符或 -> 运算符访问时）

  volatile 限定数组
  5、若以 volatile 类型限定符声明数组类型（通过使用 typedef），则数组类型无 volatile 限定，但其元素类型有(C23前)，从 C23 起 始终认为数组类型与其元素类型同等地拥有 volatile 限定 (C23起)

  volatile 限定函数
  6、若函数类型声明具有 volatile 类型限定（通过使用 typedef），则行为未定义，类同 const
  7、在函数声明中，关键词 volatile 可以出现于用以声明数组类型的函数形参的方括号内。它对数组所转换得的指针类型赋予限定，类同 const

  volatile 限定指针
  8、指向非 volatile 类型的指针可以隐式转换成指向同一或兼容类型的 volatile 限定版本的指针。逆向转换需要使用转型表达式进行
  9、注意指向 T 的指针的指针不可转换成指向 volatile T 的指针的指针；对于要兼容的两个类型，它们的限定必须相同，即 指向 char* 的指针 不可转为指向 volatile char* 的指针

  volatile 的用法
  10、static volatile 对象模仿映射于内存的 I/O 端口，而 static const volatile 对象模仿映射于内存的输入端口，例如实时时钟，volatile 关键字用于指示编译器，不要优化访问 ttyport 指针指向的内存位置。也就是说，每次访问 *ttyport 都应该直接访问内存地址 TTYPORT_ADDR，而不是使用缓存的值。这种用法通常用于硬件寄存器或 I/O 端口
  11、sig_atomic_t 类型的 static volatile 对象用于与 signal 处理函数交流，当处理信号时，信号处理函数可能会在异步执行的环境中访问某些变量。使用 volatile 和 sig_atomic_t 类型可以确保这些变量在信号处理函数中正确地被读取和写入
  12、含有对 setjmp 宏调用的函数中的局部 volatile 变量，是在 longjmp 返回后仅有保证恢复其值的局部变量，在使用 setjmp 和 longjmp 时， volatile 关键字可以保证在 longjmp 返回后，局部变量的值能够被正确恢复
  13、volatile 变量可用于禁用某些优化形式，例如禁用死存储消除，或为微基准测试禁用常量折叠，volatile 变量可以防止编译器对代码进行某些优化，例如死存储消除或常量折叠。这在编写低级代码或进行微基准测试时尤为重要
  14、volatile 变量不适合线程间交流；它们不提供原子性、同步或内存定序。读取一个被另一线程未经同步地修改的 volatile 变量，或两个未同步的线程的共时修改，对于一些数据竞争是未定义行为
  
  多线程 lock-free 问题 volatile、原子类型、内存栅栏/屏障、编译器重排、CPU乱序
  */
  volatile bool flagv = false;  // 1、volatile bool flag 表示 flag 是一个可能被外部因素（比如另一个线程或硬件中断）修改的变量
  // void set_flag() {          // 在 check_flag() 函数中，编译器不能对 while (!flag) 循环进行优化，必须每次都从内存读取 flag 的值，以确保当另一个线程调用 set_flag() 将 flag 设为 true 时，check_flag() 能够检测到这一变化
  //   flag = true;             // 如果没有使用 volatile 关键字，编译器可能会优化 while (!flag) 循环，将 flag 的值缓存到寄存器中。这意味着 flag 的变化可能不会被检测到，导致 check_flag() 无限循环
  // }                          // 在多线程编程中，volatile 关键字可以确保一个线程对变量的修改对另一个线程来说是可见的。虽然 volatile 不能保证线程安全（需要结合锁或其它同步机制），但它能保证每次访问变量时都读取最新的值
  // void check_flag() {        // volatile 关键字防止编译器对变量访问进行优化，从而确保每次访问都会直接操作内存中的值。这对于变量可能在程序之外被修改的情况（如多线程环境或硬件寄存器）尤为重要。通过使用 volatile，我们保证了程序的正确性和可预见性，即使在复杂的并发或硬件交互环境中也是如此
  //   while (!flag) {
  //     // 等待 flag 变为 true
  //   }
  //   printf("Flag is set!\n");
  // }
  // int main() {
  //   // 这里假设两个函数在不同的线程中运行
  //   set_flag();
  //   check_flag();
  //   return 0;
  // } 
  volatile int shared_var = 0;  // 在 write_to_shared 函数中，有两个对 shared_var 的写操作。由于 shared_var 被声明为 volatile，编译器保证这两个写操作在程序执行时不会被优化或重新排序。它们会严格按顺序写入内存
  // void write_to_shared() {   // 同样，在 read_from_shared 函数中，有两个对 shared_var 的读操作。编译器会确保每次读操作都直接从内存中读取，而不是使用任何缓存值
  //   shared_var = 1; // volatile write
  //   shared_var = 2; // volatile write
  // }
  // void read_from_shared() {  
  //   int x = shared_var; // volatile read
  //   int y = shared_var; // volatile read
  //   printf("x = %d, y = %d\n", x, y);
  // }
  // int main() {               // 我们可以通过编译和执行该程序，观察输出结果来验证这些行为。如果 volatile 关键字没有发挥作用，我们可能会看到编译器优化后的结果（如：寄存器缓存导致的错误读取）。但是由于 volatile 的保证，shared_var 的每次访问都会直接从内存中进行，确保了读取和写入的正确性
  //   write_to_shared();       // 编译并运行上面的代码，输出将是：x = 2, y = 2
  //   read_from_shared();      // 这说明 shared_var 的每次读取都确实从内存中获取了最新的值，且没有任何优化和重排发生。这验证了 volatile 关键字确保了访问顺序和内存同步的规则
  //   return 0;
  // } 
  // 未重排  
  // int a = 0;                 // 按照书写顺序，我们期望先执行代码块A，然后执行代码块B。然而，编译器可能会进行重排和优化，以提高性能或者减少不必要的计算。如果编译器发现代码块A和代码块B之间没有数据依赖关系（即它们之间互不影响），编译器可能会将代码块B提前执行
  // int b = 1;                 
  // // 代码块 A
  // a = b * 2;
  // // 代码块 B
  // b = 3;
  // 重排后                      // 在这种情况下，最终的a的值将是6，而不是我们预期的2。编译器这样做的目的是优化代码的执行效率，但有时这种优化会导致意想不到的结果，尤其是在多线程环境中
  // int a = 0;
  // int b = 1;
  // // 编译器重排后代码
  // // 代码块 B
  // b = 3; 
  // // 代码块 A   
  // a = b * 2; 
  // 防止编译器重排               // 为了防止编译器进行不安全的重排，可以使用内存屏障或其它同步机制，例如在多线程程序中使用volatile关键字或其它同步原语
  // volatile int a = 0;        // 使用volatile关键字后，编译器会确保对这些变量的读写操作不会被重排，从而保证程序按照预期的顺序执行。需要注意的是，volatile关键字并不能解决所有的并发问题，对于更复杂的同步需求，还需要使用互斥锁（mutex）、条件变量（condition variable）等同步原语
  // volatile int b = 1;
  // // 代码块 A
  // a = b * 2;
  // // 代码块 B
  // b = 3;
  int non_volatile_var = 42;                             // 2、非volatile变量，将非 volatile 值强制转换为 volatile 类型不起作用。要使用 volatile 语义访问非 volatile 对象，必须将其地址强制转换为指向 volatile 的指针，然后必须通过该指针进行访问
  volatile int *ptr = (volatile int *)&non_volatile_var; // 将其地址强制转换为指向volatile的指针
  *ptr = 43;                                             // 通过volatile指针进行访问
  volatile int volatile_var = 42;                        // 3、声明为volatile的变量，通过非 volatile 指针 non_volatile_ptr 访问 volatile 变量 volatile_var 是未定义行为。编译器可能会对这种访问进行优化，导致程序的行为不可预测
  int *non_volatile_ptr = (int *)&volatile_var;          // 非volatile指针
  int valuen = *non_volatile_ptr;                        // 通过非volatile指针读取volatile变量
  *non_volatile_ptr = 43;                                // 通过非volatile指针写入volatile变量
  volatile int nvlt = 1;                                 // volatile 限定类型的对象
  int* pvlt = (int*)&nvlt;                               // 非volatile指针
  int valt = *pvlt;                                      // 未定义行为
  struct svc { int i; const int ci; } sv;                // 4、s.i 类型是 int，s.ci 的类型是 const int
  volatile struct svc vs;                                // vs.i 和 vs.ci 的类型各是 volatile int 和 const volatile in
  typedef int Avl[2][3];                                 // 5、volatile 限定 数组
  volatile Avl al = {{4, 5, 6}, {7, 8, 9}};              // volatile int 的数组的数组
  int* pil = al[0];                                      // a[0] 拥有 volatile int* 类型，Initializing 'int *' with an expression of type 'volatile int[3]' discards qualifiers
  void *unqual_ptrvl = al;                               // C23 前 OK；C23 起错误 // 注：clang 即使在 C89-C17 模式也应用 C++/C23 中的规则，Initializing 'void *' with an expression of type 'volatile Avl' (aka 'volatile int[2][3]') discards qualifiers
  typedef int FuncTypec(const int);                      // 6、若函数类型声明具有 const 类型限定（通过使用 typedef），则行为未定义
  typedef int const FuncTypect(const int); 
  typedef int FuncTypevl(volatile int);                  // 若函数类型声明具有 volatile 类型限定（通过使用 typedef），则行为未定义
  typedef int volatile FuncTypevtl(volatile int);   
  void fv1(double x[volatile], const double y[volatile]);   // 7、在函数声明中，关键词 volatile 可以出现于用以声明数组类型的函数形参的方括号内。它对数组所转换得的指针类型赋予限定 
  void fv2(double * volatile x, const double * volatile y); // 类似 const 限定
  int* pvtl = 0;                                            // 8、指向非 volatile 类型的指针可以隐式转换成指向同一或兼容类型的 volatile 限定版本的指针。逆向转换需要使用转型表达式进行
  volatile int* vpvtl = pvtl;                               // OK：添加限定符（int 到 volatile int）
  pvtl = vpvtl;                                             // 丢弃限定符（volatile int 到 int）
  pvtl = (int*)vpvtl;                                       // OK：类型转换
  char *pvtlc = 0;                                          // 9、注意指向 T 的指针的指针不可转换成指向 volatile T 的指针的指针；对于要兼容的两个类型，它们的限定必须相同
  volatile char **vppvtlc = &pvtlc;                         // char* 和 volatile char* 不是兼容类型
  char * volatile *pvpvtlc = &pvtlc;                        // 添加限定符（char* 到 char* volatile）
  char ** volatile ppvvtlc = &pvtlc;                        
  // volatile short *ttyport = (volatile short*)TTYPORT_ADDR; // 10、(volatile short*)TTYPORT_ADDR 进行类型转换，将 TTYPORT_ADDR 地址转换为指向 volatile short 类型的指针。这是因为在嵌入式编程中，硬件寄存器地址通常需要进行这种类型的转换，volatile 关键字用于指示编译器，不要优化访问 ttyport 指针指向的内存位置。也就是说，每次访问 *ttyport 都应该直接访问内存地址 TTYPORT_ADDR，而不是使用缓存的值。这种用法通常用于硬件寄存器或 I/O 端口
  // for(int i = 0; i < N; ++i) *ttyport = a[i];              // *ttyport 是 volatile short 类型的左值，这段代码很可能在与某个硬件设备进行通信，比如一个串行端口（tty port）。通过将数据写入 ttyport 对应的地址，程序可以将数据发送到这个设备
  // sig_atomic_t flagsl = 0;                                 // 11、当处理信号时，信号处理函数可能会在异步执行的环境中访问某些变量。使用 volatile 和 sig_atomic_t 类型可以确保这些变量在信号处理函数中正确地被读取和写入
  // void signal_handler(int signal) {                
  //   flag = 1; // 设置一个标志，告诉主程序信号已到来
  // }
  // #include <setjmp.h>                                      // 12、在使用 setjmp 和 longjmp 时， volatile 关键字可以保证在 longjmp 返回后，局部变量的值能够被正确恢复
  // jmp_buf env;                                             // env 是一个保存程序执行环境的结构，用于存储 setjmp 函数调用时的上下文信息
  // void function() {
  //   volatile int i = 0;                                    // volatile 修饰符的作用是告诉编译器变量 i 的值可能会在程序的控制流之外发生变化，因此每次访问 i 时都要重新读取它的值，而不是使用缓存的值
  //   if (setjmp(env) == 0) {                                // setjmp(env) 保存当前的执行环境到 env 中，并返回 0，这个条件语句会在 setjmp 被初次调用时返回 0，因此会执行 i = 42;
  //     // 初次调用 setjmp, 返回 0     
  //     i = 42;
  //   } else {                                               // 当 longjmp(env, 1) 被调用时，程序的控制流会跳回到 setjmp(env) 的位置，此时 setjmp 返回 1，所以会执行 else 中的代码，打印 i 的值
  //     // 从 longjmp 返回，i 的值将保持为 42
  //     printf("i = %d\n", i);
  //   }
  // }
  // int main() {
  //   function();
  //   longjmp(env, 1);
  //   return 0;
  // }
  // volatile int x = 0;                                      // 13、volatile 变量可以防止编译器对代码进行某些优化，例如死存储消除或常量折叠。这在编写低级代码或进行微基准测试时尤为重要
  // while (x == 0) {
  //   // 这里的 x == 0 将不会被编译器优化掉
  // }
  clock_t t = clock();            // 展示用 volatile 禁用优化
  double dt = 0.0;
  for (int n = 0; n < 10000; ++n)
    for (int m = 0; m < 10000; ++m)
      dt += dt * n * m;           // 读写非 volatile 对象
  printf("Modified a non-volatile variable 100m times. Time used: %.2f seconds\n", (double)(clock() - t)/CLOCKS_PER_SEC );
  t = clock();
  volatile double vdt = 0.0;
  for (int n = 0; n < 10000; ++n)
    for (int m = 0; m < 10000; ++m) {
      double prod = vdt * n * m;  // 读 volatile 对象
      vdt += prod;                // 读写 volatile 对象
    } 
  printf("Modified a volatile variable 100m times. Time used: %.2f seconds\n", (double)(clock() - t)/CLOCKS_PER_SEC );  

  /*
  restrict(C99) 类型限定符
  在 C 类型系统中每一个独立的类型都有数个该类型的限定版本，对应 const、volatile，以及对于指向对象指针的 restrict 限定符中的一个、两个或全部三个。此节描述 restrict 限定符的效果
  在 C99 标准中引入的 restrict 类型限定符旨在帮助编译器进行优化。它告诉编译器，通过被 restrict 限定的指针所访问的内存地址不会通过任何其他指针进行访问。这种限定符主要用于指针，可以帮助编译器更好地优化代码，从而提升性能
  当你声明一个指针为 restrict 时，实际上是在告诉编译器：仅通过这个指针访问的内存不会通过其他指针访问，编译器可以假定没有其他指针访问这段内存，从而进行更激进的优化

  restrict 限定指针
  1、restrict 的使用规则 仅有指向对象类型的指针及其（可能多维的）数组(C23起)可被 restrict 限定
  restrict 只能用于指向对象（变量、数组元素等）的指针，而不能用于其他类型
  不能直接用于基本数据类型，如 int、float 等
  不能用于函数指针
  
  具体而言，以下是错误的
  int restrict *p
  float (* restrict f9)(void)

  2、限制语义仅适用于左值表达式；例如，强制转换为受限限定指针或调用返回受限限定指针的函数不是左值，并且限定符没有效果
  restrict 限定符的语义仅适用于左值表达式。这句原文的意思是说，只有在左值上下文中，restrict 限定符才有实际的作用。如果是在非左值上下文中使用，那么 restrict 限定符是没有效果的
  左值（lvalue）：表示一个对象，可以出现在赋值操作符的左侧。例如变量、数组元素、指针解引用等
  右值（rvalue）：表示一个值（数据），不能出现在赋值操作符的左侧。例如常量、表达式的结果、函数调用的返回值等

  3、在声明受限制指针 restrict P 的块的每次执行期间（通常是在P作为函数参数的函数体的每次执行期间），如果通过P（直接或间接）可访问的某个对象以任何方式被修改，那么在该块中对该对象的所有访问（包括读取和写入）都必须通过P（直接或间接）进行，否则行为是未定义的
  在声明了 restrict 指针 P 的块的每次执行（典型例子是函数体的执行，其中 P 为函数形参）中，若某个可由 P（直接或间接）访问的对象会被任何手段修改，则该块中对该对象的所有访问（读或写），都必须经由 P 进行，否则行为未定义

  4、如果对象从未被修改，可以通过不同的受限限定 restrict 指针进行别名化和访问（请注意，如果通过别名化的受限限定指针 restrict 所指向的对象本身又是指针，这种别名化可能会抑制优化）
  如果一个对象从未被修改，那么即便是通过不同的 restrict 限定指针进行别名化访问，也不会违反 restrict 的语义。换句话说，如果你保证对象只读，那么多个 restrict 限定指针访问同一对象是安全的，不会破坏编译器的优化假设
  如果 restrict 限定指针本身指向的是另一个指针（而不是基本类型或常规对象），那么这种别名化可能会抑制优化。原因在于指向指针的指针可能会引入额外的间接访问，编译器很难确保这种间接访问不会引入额外的修改或冲突，从而限制优化的能力
  指针指向指针：在这种情况下，restrict 指针指向的是一个指针，而不是直接指向具体的数据对象
  间接访问：通过 restrict 指针间接访问最终的数据对象，是通过两步操作完成的：先访问指针，再通过这个指针访问数据对象

  5、从一个受限指针 restrict 赋值给另一个受限指针 restrict 是未定义行为，除非是从某个外部块中的指向对象的指针赋值给某个内部块中的指针（包括在调用具有受限指针 restrict 参数的函数时使用受限指针 restrict 参数），或者在从函数返回时（以及在其他情况下，当源指针所在的块结束时）
  在 C99 标准中，restrict 关键字的使用有一些严格的规则，以确保编译器能够安全地进行优化。特别是，将一个 restrict 指针赋值给另一个指针的行为在某些情况下是未定义的，但在其他特定情况下是允许的
  未定义行为：一般情况下，将一个 restrict 指针赋值给另一个指针（包括另一个 restrict 指针或普通指针）是未定义行为。这是因为这样赋值可能破坏编译器对 restrict 指针独占访问内存区域的假设
  
  合法行为：在特定情况下，这种赋值是允许的，并且行为是定义明确的。主要包括以下几种情况
  将指向外部块的 restrict 指针赋值给内部块中的指针
  将 restrict 指针作为参数传递给函数
  从函数返回 restrict 指针
  当前一个 restrict 指针的生命周期结束时，将其赋值给另一个指针

  6、restrict 指针可以自由地赋值给非 restrict 指针，只要编译器还能优化代码，优化机会还是会保留的

  restrict 限定数组
  7、若以 restrict 类型限定符声明数组类型（通过使用 typedef），则数组类型无 restrict 限定，但其元素类型有 restrict 限定 (C23前)始终认为数组类型与其元素类型同等地拥有 restrict 限定(C23起)
  C23 之前：restrict 关键字仅应用于数组元素类型，而不是整个数组类型。将带有 restrict 限定符的对象的地址赋值给无限定符的指针是合法的
  C23 起：restrict 关键字应用于整个数组类型及其元素类型。将带有 restrict 限定符的对象的地址赋值给无限定符的指针是非法的，因为这违反了 restrict 的独占访问假设

  restrict 限定函数参数
  8、在函数声明中，关键词 restrict 可以出现于方括号内，用以声明函数参数的数组类型。它对数组所转换得的指针类型赋予进行限定，即数组转为指针后限定
  void f(int n, float * restrict r, float * restrict s)
  void f(int m, int n, float a[restrict m][n], float b[restrict m][n]); 参数 a 和 b 都是二维浮点数组，且它们的每一个指针元素都带有 restrict 限定符。这意味着在函数 f 的执行期间，编译器可以假设通过 a 和 b 访问的内存区域是独立的，不会重叠。这种假设使得编译器可以进行更多的优化

  注解
  restrict 限定符的预期用途（如同 “register” 存储类）是促进优化，从组成一个符合标准的程序的所有预处理翻译单元中删除该限定符的所有实例不会改变其含义（即可观察的行为）
  restrict 限定符的预期用途（类似于 register 存储类）是促进优化。如果从构成符合标准的程序的所有预处理翻译单元中删除所有 restrict 限定符，该程序的含义（即可观察的行为）不会改变

  编译器可以忽略任何一个或全部使用 restrict 的别名使用暗示
  编译器可以自由地忽略任何或所有与 restrict 使用相关的别名（aliasing）含义。这意味着即使程序员使用了 restrict，编译器也可以选择不利用这些信息进行优化

  欲避免未定义行为，程序员应该确保 restrict 限定指针所做的别名引用断言不会违规
  为了避免未定义行为，程序员必须确保由 restrict 限定的指针所做的别名断言不被违反。也就是说，程序员需要保证使用 restrict 限定符的指针确实不会与其他指针指向同一内存区域，否则可能会导致未定义行为

  许多编译器提供作为 restrict 对立面的语言扩展：指示即使指针类型不同，也可以别名使用的属性：“may_alias”（gcc）
  许多编译器提供了一种与 restrict 相反的语言扩展，用于指示即使指针类型不同，这些指针也可能别名。例如，GCC 提供的 may_alias 属性，may_alias 扩展是一种编译器属性，告诉编译器即使指针类型不同，这些指针也可能指向相同的内存区域。这与 restrict 的作用相反。restrict 用于指示某个指针是唯一访问某一块内存区域的方式，从而允许更激进的优化，而 may_alias 则用于指示指针可能别名，从而避免优化导致的错误
  int * __attribute__((may_alias)) ptr; 这个属性告诉编译器，即使 ptr 的类型与其他指针不同，它们也可能指向相同的内存区域，编译器应考虑这种可能性，在没有 may_alias 属性的情况下，编译器可能假设 float 类型的指针和 int 类型的指针不会指向同一内存区域，从而进行一些不安全的优化

  使用模式
  9、restrict 限定指针有几种常用的使用模式
  文件作用域
  函数形参
  块作用域
  结构体成员

  */
  // int restrict *resp;              // 1、错误 restrict 限定的是 *resp
  // float (* restrict resf9)(void);  // 错误 restrict 不能用于函数指针，restrict 只应限定指针，而不应直接限定基本数据类型或函数指针  
  int * restrict restp;               // restp 是一个指向 int 的指针，并且被 restrict 限定
  float * restrict restq;             // restq 是一个指向 float 的指针，并且被 restrict 限定
  int * restrict restarr[10];         // restarr 是一个数组，数组的每个元素是一个被 restrict 限定的指向 int 的指针
  int * restrict restp1;                  // 2、限制语义仅适用于左值表达式
  *restp1 = 10;                           // 左值上下文中的 restrict：这里 restp1 是一个左值，并且有 restrict 限定，所以编译器可以进行优化  
  int *restq1 = (int * restrict) restp1;  // 非左值上下文中的 restrict（无效）：这里 restp1 不是左值，restrict 限定无效
  *restq1 = 10;                           // 这行代码中，restq1 是一个左值，但 restrict 限定信息已经丢失 ，(int * restrict) p 是一个强制转换表达式，结果不是左值，因此 restrict 限定符无效。赋值给 q 后，q 的 restrict 限定符信息已经丢失，所以在 *q = 10 这一行中，编译器不能利用 restrict 信息进行优化 
  int * restrict barrest(void);           // 函数返回值中的 restrict（无效）：bar() 函数返回一个 restrict 限定的指针，但返回值本身不是左值，因此 restrict 限定符无效
  // void f(int n, int * restrict p, int * restrict q) {
  //   while (n-- > 0)                    // 3、必须由声明了 restrict 的指针 p 进行所有访问（读或写），否则会发生定义行为
  //     *p++ = *q++;                     // 通过 *p 修改的对象与通过 *q 读取的无一相同
  //                                      // 编译器可以自由地优化、向量化、做页面映射等等。
  // }
  // void g(void) {
  //   extern int d[100];
  //   f(50, d + 50, d);                  // OK，不会 p 和 q 不会重复访问
  //   f(50, d + 1, d);                   // 未定义行为：f 中的 p 和 q 均可访问 d[1]
  // }
  const int * restrict crestp;            // 4、crestp 是 restrict 限定的指针，并且它们指向的对象是 const 类型（只读）。因为对象不会被修改，编译器可以假设通过 crestp 的访问不会相互影响，从而进行优化
  int acrestp = *crestp;
  int ** restrict crestpp;                // crestpp 是 restrict 指向指针的指针。因为 crestpp 指向的对象本身是指针，编译器在处理间接访问 *crestpp 时，难以保证这些指针不会引入冲突或修改，从而可能抑制优化
  int *acrestpp = *crestpp;               
  *acrestpp = 10;                         // 由于 crestpp 指向的是指针，它们的间接访问可能引入冲突，限制优化
  // 初始化 crestpp：crestpp 是一个 restrict 指向指针的指针。它指向某个 int* 类型的指针
  // 间接访问 *crestpp：int *acrestpp = *crestpp; 这行代码首先通过 crestpp 访问到一个 int* 类型的指针，并将其赋值给 acrestpp
  // 修改内存 *acrestpp = 10;：这行代码通过 acrestpp 修改了内存中的一个整数值
  // 地址冲突的潜在风险：编译器无法保证 *crestpp 指向的 int* 指针没有通过其他途径被修改或访问。也就是说，crestpp 指向的内存位置可能还被其他指针间接访问或修改，从而引入内存访问冲突
  // 优化限制：为了进行优化，编译器需要确定内存访问彼此独立且没有冲突。当无法确定时，编译器不得不保守地假设可能存在冲突，从而限制优化。例如，它无法重排序指令或进行寄存器重用优化，因为无法确定对内存的访问是否安全
  int ** restrict crestpp0;               // crestpp 是一个 restrict 指针，指向一个 int* 指针
  int *acrestpp1 = *crestpp0;             // acrestpp1 和 acrestpp2 都间接指向 crestpp 指向的 int* 指针
  int *acrestpp2 = *crestpp0;             // 但是编译器无法确定 *crestpp 是否会被其他指针（例如 acrestpp2）间接访问和修改。这意味着编译器必须假设 *crestpp 可能通过其他指针被修改，从而抑制某些优化
  *acrestpp1 = 10;
  *acrestpp2 = 20;
  int* restrict restrictp1 = &a;          // 5、从一个受限指针 restrict 赋值给另一个受限指针 restrict 是未定义行为
  int* restrict restrictp2 = &b;
  restrictp1 = restrictp2;                // 未定义行为
  int * restrict outerrestp;              // 将指向外部块的 restrict 指针赋值给内部块中的指针，外部块的 restrict 指针
  {
    int *outerrestq = outerrestp;         // 合法：outerrestq 在 outerrestp 所在块的内部
  }
  // void process_array(int * restrict arr); // 将 restrict 指针作为参数传递给函数
  // int * restrict arrrestp;
  // process_array(arrrestp);                // 合法：将 restrict 指针作为函数参数传递
  // int * restrict get_restricted_ptr(int * restrict input) {
  //   return input;                         // 合法：从函数返回 restrict 指针
  // }  
  int * restrict outerrestp1;                // 外部块的 restrict 指针
  {
    int *outerrestq1 = outerrestp1;          // 合法：outerrestq1 在 outerrestp1 所在块的内部
  }
  int *outerrestqr = outerrestp1;            // outerrestp1 的生命周期结束后，可以将其赋值给另一个指针
  // void f(int n, float * restrict r, float * restrict s) {
  //   float * p = r, * q = s;               // OK    
  //   while (n-- > 0)                       // 6、restrict 指针可以自由地赋值给非 restrict 指针，只要编译器还能优化代码，优化机会还是保留
  //     *p++ = *q++;                        // 几乎肯定优化成仅如 *r++ = *s++ 一般
  // }
  typedef int *array_t[10];                  // 7、若以 restrict 类型限定符声明数组类型（通过使用 typedef），则数组类型无 restrict 限定，但其元素类型有 restrict 限定 (C23前)始终认为数组类型与其元素类型同等地拥有 restrict 限定(C23起)
  // restrict array_t a;                        // a 的类型是 int *restrict[10]，在这个声明中，restrict 关键字应用于数组的元素类型，而不是数组类型本身。也就是说，数组 a 的每个元素都是一个 int * restrict 类型的指针。这意味着每个指针都具有 restrict 限定符，但数组 a 本身并不具有 restrict 限定符，注：clang 和 icc 以 array_t 不是指针类型为由拒绝
  // void *unqual_ptr = &a;                     // C23 前 OK 在这种情况下，unqual_ptr 是一个 void* 类型的指针，指向数组 a，这种转换是合法的，因为 restrict 限定符只影响指针的行为，而不影响数组本身； C23 起错误，在 C23 标准及之后的标准中，这种转换被视为非法，因为 restrict 限定符适用于整个数组类型和它的元素类型，赋值给无限定符的指针会违反 restrict 的独占访问假设，clang 即使在 C89-C17 模式也应用 C++/C23 中的规则，
  // void f(int m, int n, float a[restrict m][n], float b[restrict m][n]);
  // void g12(int n, float (*p)[n]) {           // 8、在函数声明中，关键词 restrict 可以出现于方括号内，用以声明函数参数的数组类型。它对数组所转换得的指针类型赋予进行限定
  //   f(10, n, p, p+10);                       // OK，在第一次调用中，m 的值是 10，因此 a 和 b 分别指向 p 和 p + 10，即 p 指向的数组和紧接在其后的数组。这种情况是安全的，因为 p 和 p + 10 指向的内存区域不会重叠                 
  //   f(20, n, p, p+10);                       // 可能是未定义行为（取决于 f 所为），在第二次调用中，m 的值是 20，因此 a 和 b 分别指向 p 和 p + 10，即 p 指向的数组和紧接在其后的 20 个数组。在这种情况下，p 和 p + 10 所指向的内存区域可能存在重叠，具体取决于 n 的值和 f 函数的实现。如果 n 的值较小，例如只有 1，那么 p 和 p + 10 实际上可能指向同一个内存区域的部分
  // }


  /* 
  constexpr(C23)

  对齐说明符(C11)
      内存对齐是一种优化技术，旨在提高程序的性能和减少内存访问错误。4字节对齐和8字节对齐是两种常见的内存对齐方式。以下是它们的主要区别和相关概念
      4字节对齐
      定义：数据在内存中的起始地址必须是4的倍数
      适用对象：一般用于较小的数据类型，例如int（通常占用4字节）
      优点：
      可以减少内存空间的浪费
      对于32位系统，访问速度较快
      使用场景：适合那些需要频繁访问的4字节数据类型
    
      8字节对齐
      定义：数据在内存中的起始地址必须是8的倍数
      适用对象：适用于较大的数据类型，例如double（通常占用8字节）和64位系统的指针
      优点：
      在64位系统上，访问速度较快，因为64位处理器通常一次能处理8字节数据
      可以避免某些架构上由于未对齐访问带来的性能损失和潜在的硬件异常
      使用场景：适合那些需要频繁访问的8字节数据类型以及64位系统上的数据
      
      假如在一块内存中存储两个数据，一个是4字节的int，另一个是8字节的double
      4字节对齐：
      int数据存储在地址0x0000处
      double数据需要存储在地址0x0004处（因为4字节对齐），但这样会导致double数据的访问可能需要两次读取操作，影响性能
      
      8字节对齐：
      int数据存储在地址0x0000处
      double数据存储在地址0x0008处（因为8字节对齐），保证了数据的高效访问

  存储期与链接

  外部及试探性定义
  
  typedef
  
  静态断言(C11)
  
  属性(C23)  
  */

#endif // DECLARATIONS declarations 声明

  return 0;  
}