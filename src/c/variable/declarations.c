/**
* @file              declarations.c
* @brief             声明是一种引入一个或多个标识符到程序中，并指定其含义及属性的 C 语言构造
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.02
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.02 <td>0.1             <td>brightl         <td>声明定义、使用、特性
* </table>
*/

#include "c/variable/variable.h"
#include <stdio.h>
#include <assert.h>

/**
* @brief             声明是一种引入一个或多个标识符到程序中，并指定其含义及属性的 C 语言构造
*
* @note              声明可以出现在任何作用域中。每个声明以分号结束（类似语句），并由两 (C23前)三 (C23起)个独立部分组成
*/
#define DECLARATIONS
// 声明  
// 指针
// 数组
// enum
// struct
// union
// 位域
// 原子类型(C11)

// const
// volatile
// restrict(C99)

// 对齐说明符(C11)

// 存储期与链接
// 外部及试探性定义

// typedef

// 静态断言(C11)

// 属性(C23)

/**
* @brief             声明是一种引入一个或多个标识符到程序中，并指定其含义及属性的 C 语言构造
* @return  int       Return Description
*
* @note              声明可以出现在任何作用域中。每个声明以分号结束（类似语句），并由两 (C23前)三 (C23起)个独立部分组成
*/
int declarations_fn(void) {
#ifdef DECLARATIONS
  /*
  声明
  在 C 语言中，声明是一种构造，将一个或多个标识符引入程序中，并指定它们的含义和属性
  声明可以出现在任何作用域中。每个声明都以分号结尾（就像一条语句一样），并且由两部分（C23前）或三部分（C23起）不同的部分组成
  说明符与限定符 声明符与初始化器(可选);        (1)	
  属性说明符序列 说明符与限定符 声明符与初始化器;	(2)	(C23起)
  属性说明符序列;	                           (3) (C23起)
  
  说明符和限定符— 下列以任意顺序排列的由空格分隔的列表
  类型说明符：void、算术类型名、原子类型名、由 typedef 声明在前面引入的名称、struct、union 或 enum 说明符、typeof 说明符 (C23起)
  零或一个存储类说明符：typedef、constexpr、auto、register、static、extern、_Thread_local
  零或多个类型限定符：const、volatile、restrict、_Atomic
  (只在声明函数时）零或多个函数说明符：inline、_Noreturn
  零或多个对齐说明符： _Alignas
  声明符与初始化器- 由声明符组成的以逗号分隔的列表（每个声明符提供额外的类型信息和 / 或要声明的标识符）。声明符可以伴有初始化器。枚举、结构体和联合体声明可以省略声明符，在这种情况下，它们仅引入枚举常量和 / 或标签
  属性说明符序列-	(C23)可选的属性列表，应用到被声明的实体，或若单独出现则构成属性声明

  1-2) 简单声明 引入一个或多个表示对象、函数、结构体 / 联合体 / 枚举标签、类型定义或枚举常量的标识符
  3) 属性声明 不声明任何标识符，如果标准未指定其含义，则具有实现定义的含义
  一个声明引入的每个标识符类型是通过 类型说明符 所指定的类型及其 声明符 所应用的类型修饰决定的

  1、如果使用 auto 说明符，变量的类型也可能被推断出来（C23起）
  2、属性(C23起)可在 说明符与限定符 中出现，在这种情况下，它们适用于由前面的说明符确定的类型
  
  3、声明符 每个声明符是下列之一
  标识符 属性说明符序列(可选)	                                                    (1)	
  ( 声明符 )	                                                                 (2) 
  * 属性说明符序列(可选) 限定符(可选) 声明符	                                      (3)	
  无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]  (4)	
  无指针声明符 ( 形参或标识符 )                                               	  (5)	
  1) 此声明符引入的标识符，即这是最基本的声明形式，就是简单地给出一个标识符（如变量名、函数名等），并且可以选择性地跟上属性说明符序列。属性说明符序列可以用于指定一些额外的属性等（C23起这些属性可在这个位置出现） _Alignas(8) double value;
  2) 任何声明符都可以用括号括起来; 这是引入指向数组的指针和指向函数的指针所必需的，即形式：任何声明符都可以用括号括起来。这种形式看似简单，但它在一些复杂的类型声明场景中非常有用，特别是在声明指向数组的指针和指向函数的指针时是必需的 int (*ptr_to_array)[5]; int (*ptr_to_function)(int, double);
  3) 指针声明符：声明 S * cvr D; 将D声明为受 cvr 限定的指向由 S 确定的类型的指针，即这是用于声明指针的形式。首先是*符号表示指针，然后可以跟上属性说明符序列（用于指定指针相关的额外属性，不过这种情况相对较少见），接着是限定符（如const、volatile等，用于进一步限定指针所指向的类型的特性），最后是另一个声明符，整个式子将最后的声明符所声明的类型确定为指针所指向的类型 _Alignas(4) char * restrict ptr3;
  4) 数组声明符：声明 S D[N] 声明 D 为有 N 个 S 所确定类型对象的数组，无指针声明符是 除未被括号包围的指针声明符 以外的其他任何声明符，即这是用于声明数组的形式。“无指针声明符” 是指除未被括号包围的指针声明符以外的其他任何声明符，先通过前面的部分确定数组元素的类型，然后通过[ static(可选) 限定符(可选) 表达式 ]或[ 限定符(可选) * ]来确定数组的大小或特性 int arr[5]; int arr2[static 3]; double * arr3[const 2];
  5) 函数声明符：声明 S D(params) 声明 D 为接收参数 params 并返回 S 的函数，无指针声明符是 除未被括号包围的指针声明符 以外的其他任何声明符，即这是用于声明函数的形式。“无指针声明符” 同样是指除未被括号包围的指针声明符以外的其他任何声明符，先通过前面的部分确定函数的返回类型，然后通过( 形参或标识符 )来确定函数的参数情况
  这种语法背后的推理是，当由声明符声明的标识符出现在与声明符形式相同的表达式中时，它将具有由类型说明符序列指定的类型
  这种声明语法背后的关键推理是，当由声明符声明的标识符出现在与声明符形式相同的表达式中时，它将具有由类型说明符序列指定的类型。例如，如果我们声明了一个指针int *ptr，那么当我们在表达式中使用ptr时，比如*ptr = 10;，编译器就知道ptr是一个指向整数的指针，所以可以通过解指针操作（*）来访问和修改所指向的整数的值。同样，对于数组声明int arr[5]，当我们在表达式中使用arr时，编译器就知道它是一个包含 5 个整数的数组，并且可以根据数组的索引规则来访问其中的元素。对于函数声明也是如此，当我们调用一个函数时，编译器根据函数的声明就能准确知道函数的返回类型、参数类型和数量等信息，从而正确地执行函数调用和处理返回值
  通过这样一套声明规则，C 语言能够精确地表达各种复杂的类型关系，使得程序员可以准确地定义和使用不同类型的变量、指针、数组和函数等，同时也让编译器能够准确地理解程序的意图并进行正确的编译处理

  4、每个不是另一个声明符一部分的声明符末尾都是一个 “序列点”
  序列点（Sequence Point）的概念 在 C 和 C++ 语言中，序列点是程序执行过程中的一个特殊点，在这个点上，所有的副作用（side - effect）都已经完成，并且后续对同一对象的访问将看到这些副作用的结果。副作用是指对一个对象（如变量）进行修改的操作，例如赋值操作。序列点保证了程序执行的顺序和逻辑的确定性，避免了在复杂表达式求值过程中由于不同的求值顺序可能导致的歧义
  声明符与序列点的关系 当一个声明符不是另一个声明符的一部分时，它的末尾被视为一个序列点。这意味着在这个位置，之前声明过程中可能产生的任何副作用（实际上在声明过程中通常没有副作用，但从语法规则角度这样定义更严谨）都已经完成
  例如，在声明多个变量时：int a = 1, b = a + 1;，在变量a声明结束的位置（也就是第一个声明符int a = 1的末尾）是一个序列点。这样，在初始化b时，a的值已经被确定为1，编译器就可以按照正确的顺序来处理这个初始化表达式，不会出现因为a的值不确定而导致b的初始化出现歧义的情况
  这种规则有助于编译器正确地解析和处理声明语句，特别是在涉及复杂的初始化表达式和多个变量声明的情况下。它保证了变量的初始化顺序和赋值操作按照预期的顺序进行，从而确保程序的正确性和可预测性。如果没有这样的规则，在复杂的声明语句中，编译器可能会因为不确定求值顺序而产生错误的代码生成或者无法正确处理声明

  在所有情况下，属性说明符序列是一个可选的属性序列（自 C23 起）。当紧接在标识符后面出现时，它适用于正在声明的对象或函数
  
  5、定义
  定义是一种声明，它提供了关于其所声明的标识符的所有信息
  每个 enum 或 typedef 的声明都是一个定义
  对于函数，包含函数体的声明是一个函数定义
  对于对象而言，分配存储（自动存储或静态存储，但不是外部存储）的声明是定义，而不分配存储（外部声明）的声明不是定义
  对于结构体和联合体，指定其成员列表的声明是定义

  6、重声明
  如果在同一作用域中，对于相同标识符的另一个声明已在前面出现，那么声明不能引入该标识符，除非
  具有链接（外部或内部）的对象声明可以重复
  非可变长度数组（Non-VLA）类型别名（typedef）只要命名的是相同类型就可以重复
  struct（结构体）和union（联合体）声明可以重复
  这些规则会简化头文件的使用

  7、声明注解
  在 C89 中，任何复合语句（块作用域）内的声明必须出现在块的开头，在任何语句之前
  这样规定的主要原因是为了让编译器在处理复合语句时能够更清晰、有序地管理变量的作用域和内存分配等操作。在代码阅读和理解上，也使得变量的声明集中在块的开头，便于开发者快速了解在该块内会使用哪些变量。但这种规定也有一定的局限性，比如在一些复杂的逻辑中，如果需要根据前面语句的执行结果来动态决定是否声明某个变量，就会受到限制，不过这在 C89 之后的标准（如 C99 等）中有了改进，允许在块内更灵活地声明变量

  此外，在 C89 中，返回整数类型的函数可以通过函数调用运算符隐式声明，并且在使用旧式函数定义时，类型为整数的函数参数不必声明
  在 C89 中，返回整数类型的函数可以通过函数调用运算符隐式声明。这意味着如果在程序中调用了一个尚未显式声明的函数，并且该函数最终返回的是整数类型，编译器会自动为其生成一个隐式声明，默认该函数接受任意数量的参数（实际上这种行为可能会带来潜在的错误风险）

  空声明符是被禁止的；一个简单声明必须至少有一个声明符，或者声明至少一个结构体 / 联合体 / 枚举标签，或者引入至少一个枚举常量
  int ; // 这就是一个空声明符的错误示例，只是写了数据类型 'int'，但没有指定具体要声明的对象（如变量名等），因为它没有明确地告诉编译器要创建和处理什么样的对象，编译器无法确定后续该如何为这个未明确的对象分配内存、处理其类型相关操作等，所以这样的代码在编译时会报错

  如果声明符的任何部分是可变长度数组（VLA）声明符，则整个声明符的类型被称为 “可变修改类型”。由可变修改类型定义的类型也是可变修改的（VM），即由可变修改类型定义的类型也是可变修改的：一旦某个类型被判定为可变修改类型，那么由它所定义的其他类型也会继承这种可变修改的特性。比如，如果有一个函数的参数类型是上述提到的指向可变长度数组的指针（可变修改类型），那么在函数内部使用该参数来定义新的类型时，新的类型也依然是可变修改类型
  任何可变修改类型的声明只能出现在块作用域或函数原型作用域，不能是结构体或联合体的成员。尽管可变长度数组（VLA）只能具有自动存储期或分配的存储期，但诸如指向 VLA 的指针这样的可变修改类型（VM）可以是静态的。对于可变修改类型的使用还有其他限制，参见 goto、switch、longjmp
  只能出现在块作用域或函数原型作用域：可变修改类型的声明有严格的作用域限制。它只能出现在块作用域（也就是在花括号 {} 括起来的代码块内，比如函数体内部的局部变量声明所在的作用域）或者函数原型作用域（在函数声明但未定义具体函数体时，函数参数所在的作用域）
  存储期特性 VLA 本身的存储期限制：可变长度数组（VLA）自身只能具有自动存储期（也就是在进入其所在的函数块时创建，函数块执行结束时销毁）或分配的存储期（通过动态分配内存获得，如使用 malloc 等函数）
  指向 VLA 的指针等可变修改类型的存储期灵活性：尽管 VLA 有存储期限制，但诸如指向 VLA 的指针这样的可变修改类型（VM）却可以是静态的。这意味着可以在程序的静态存储区声明一个指向可变长度数组的指针，它在程序的整个生命周期内都存在，与 VLA 本身的存储期特性有所不同
  参见 goto、switch、longjmp：对于可变修改类型的使用还存在其他一些限制，具体可以参考在涉及 goto 语句、switch 语句以及 longjmp 函数（用于非局部跳转）等相关内容时的情况。比如，在使用 goto 语句进行跳转时，如果跳转目标和源位置涉及到可变修改类型的变量，可能会导致一些未定义行为。这是因为 goto 语句的跳转可能会绕过可变修改类型变量的初始化或其他必要的处理步骤，从而使程序的运行状态变得不可预测。同样，在 switch 语句和 longjump 函数的使用中，也需要特别注意与可变修改类型相关的问题，以避免出现未定义行为

  静态断言 从 C 语法的角度来看被视为声明（因此它们可以出现在任何声明可以出现的地方），但它们不会引入任何标识符，也不遵循声明语法
  属性声明也被视为声明（以便它们可以出现在任何声明可以出现的地方），但它们不会引入任何标识符。单独的; 如果没有属性说明序列，则不是属性声明，而是一条语句（C23起）
  在 C 语言的语法中，一个单独的分号 ; 如果没有前面跟着属性说明符序列，那么它不被看作是属性声明，而是被认定为一条语句，语句在 C 语言程序中是执行某种操作或者表达某种逻辑关系的基本单元。单独的分号作为语句，在语法上是一种空语句，它不执行任何实际的操作，但在程序的语法结构中是合法存在的，并且有时候在程序逻辑需要的情况下会被用到
  */
  int a, *b=NULL;                             // “int”是类型说明符，“a”是声明符，“*b”是声明符， NULL 是初始化器
  const int *f(void);                         // “const”是类型限定符，“int”是类型说明符，“*f(void)”是声明符
  static const _Alignas(8) long long scai;
  inline const long long scaif(void);
  const _Alignas(8) auto int scaai  = 1;      // 1、在 C23 之前，auto关键字主要用于函数内局部变量的声明，它隐含表示变量具有自动存储期（即变量在进入其所在的函数块时创建，函数块执行结束时销毁），但变量的类型需要明确指定
  const _Alignas(8) auto scaa  = 1;           // 2、如果使用 auto 说明符，变量的类型也可能被推断出来（C23起），从 C23 起，auto获得了新的用途，它可以像在 C++ 中那样用于类型推断。这意味着编译器会根据变量的初始化表达式自动推断出变量的类型

  _Alignas(8) double value;                   // 3、标识符 属性说明符序列(可选)，普通声明	
  int (*ptr_to_array)[5];                     // ( 声明符 )，指向数组的指针  
  int (*ptr_to_function)(int, double);        // ( 声明符 )，指向函数的指针	   
  _Alignas(8) char * restrict ptr3;           // * 属性说明符序列(可选) 限定符(可选) 声明符，指针
  int arr[5];                                 // 无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]
  // int arr2[static 3];                      // 无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]
  // double * arr3[const 2];                  // 无指针声明符 [ static(可选) 限定符(可选) 表达式 ] 或 无指针声明符 [ 限定符(可选) * ]，'double *' 是无指针声明符（因为这里不是未被括号包围的指针声明符形式）
  double multiply(double num1, double num2);  // 无指针声明符 ( 形参或标识符 )
  int* add(int a, int b);                     // 无指针声明符 ( 形参或标识符 )，'int*' 是无指针声明符（因为这里不是未被括号包围的指针声明符形式）
  
  struct C { int member; } obj, *pObj = &obj;         // “int”是类型说明符，“member”是声明符，“struct C { int member; }”是类型说明符，声明符“obj”定义 struct C 类型的对象，声明符“*pObj”声明指向 struct C 的指针，初始化器“= &obj”提供该指针的初值 
  int ai = 1, *pi = NULL, fi(void), (*pfi)(double);   // 类型说明符是“int”，声明符“ai”定义一个 int 类型对象 初始化器“=1”提供其初值，声明符“*pi”定义一个指向 int 指针类型的对象 初始化器“=NULL”提供其初值，声明符“fi(void)”声明接受 void 并返回 int 的函数，声明符“(*pfi)(double)”定义一个指向接受 double 并返回 int 的函数的指针类型对象
  int (*(*foo)(double))[3] = NULL;                    // foo是一个指向函数的指针，接受double类型参数，返回值是指向3个int元素数组的指针
  // 类型说明符是“int”
  // 1. 声明符“(*(*foo)(double))[3]”是数组声明符：所声明类型是“3 个 int 的数组的 /嵌套声明符/”
  // 2. 嵌套声明符是“（*(*foo)(double)）”，是指针声明符 所声明类型是“/嵌套声明符/ 指向 3 个 int 的数组的指针”
  // 3. 嵌套声明符是“(*foo)(double)”，是一个函数声明符 所声明类型是“/嵌套声明符/ 接受 double 并返回指向 3 个 int 的数组的指针的函数”
  // 4. 嵌套声明符是“(*foo)”，是一个（有括号，函数声明符所要求）指针声明符 所声明类型是“/嵌套声明符/ 指向接受 double 并返回指向 3 个 int 的数组的指针的函数的指针”
  // 5. 嵌套声明符是“foo”，是一个标识符 该声明引入一个标识符“foo”，以指代一个对象，其类型为 “指向接受 double 并返回指向 3 个 int 的数组的指针的函数的指针”
  // 初始化器“= NULL”提供此指针的初值
  // int x = (*(*foo)(1.2))[0];                      // 如果 “foo” 在声明符形式的表达式中被使用，它的类型将是整型 int

  int ax = 1, bx= ax + 1;                            // 4、每个不是另一个声明符一部分的声明符末尾都是一个 “序列点”

  // int foo5(double);                               // 5、声明：函数声明
  // int foo5(double x) { return x; }                // 定义：函数定义：包含函数体
  enum { ONE = 1, TWO } e;                           // 每个 enum 或 typedef 的声明都是一个定义
  typedef int int_t;
  extern int ne;                                     // 声明，对于对象而言，分配存储（自动存储或静态存储，但不是外部存储）的声明是定义，而不分配存储（外部声明）的声明不是定义
  int nel = 10;                                      // 定义 
  struct X;                                          // 声明
  struct X { int n; };                               // 定义，对于结构体和联合体，指定其成员列表的声明是定义

  extern int xl;                                     // 6、有链接对象（外部或内部）的声明可以重复
  extern int xl;                                     // OK
  typedef int int_t; 
  typedef int int_t;                                 // OK，非 VLA typedef 可以任意重复，只要它指名同一类型
  struct X;
  struct X;                                          // OK，struct 和 union 声明可以重复

  int n7;                                            // 7、定义注解
  int arr7[n7];                                      // 这里假设n7是一个在运行时才能确定值的变量，所以arr7是一个可变长度数组（VLA）声明符
  int (*ptr7)[n7];                                   // 因为声明符的一部分（即所指向的类型是可变长度数组int arr7[n7]）是VLA声明符，所以整个声明符（*ptr7）的类型就是可变修改类型
  _Static_assert(2 + 2 * 2 == 6, "Lucky guess!?");   // 静态断言 从 C 语法的角度来看被视为声明（因此它们可以出现在任何声明可以出现的地方），但它们不会引入任何标识符，也不遵循声明语法
  
  /*
  指针，详细移至 pointers.c 文档
  指针是一种对象类型，它引用函数或另一种类型的对象，可以添加限定符。指针亦可以不引用任何内容，这通过一个特定的空指针值指示
  指针是用来存储内存地址的数据类型，可以引用（指向）函数或其他类型的对象。通过指针，可以访问和修改这些对象。指针可以是空指针，表示它不指向任何有效对象或函数。指针还可以添加限定符，如 const，以限制其使用

  指针语法
  类型说明符序列 * 属性说明符序列(可选) 限定符序列(可选) 声明符
  在指针声明的声明文法中：
  类型说明符序列 代表所指向的类型可以是函数或对象类型也可以是不完整类型、
  属性说明符序列 属性在C23引入应用到被声明的指针的可选属性列表
  限定符序列 包括 const、volatile等修饰符它们修饰指针或指针所指向的对象
  指针符号 * 
  声明符 包含指针的标识符以及指针的层次结构例如指向指针的指针

  使用：指针用于间接使用，这是种普遍存在的编程技巧；它们可以用于实现按引用传递语义，访问有动态存储期的对象，实现“可选”类型（使用空指针值），结构体间的聚合关系，回调（使用指向函数指针），泛型接口（使用指向 void 的指针）以及其他更多
  按引用传递语义 在函数调用时，我们通常按值传递参数，这意味着函数得到的是参数的一个副本。有时我们希望函数能够直接修改传递给它的变量，这时可以使用指针来实现按引用传递
  访问有动态存储期的对象 通过动态内存分配（如 malloc 和 free），我们可以在运行时分配和释放内存，这些内存块的生命周期可以跨越函数调用
  实现 “可选” 类型 指针可以用来表示一个“可选”值（例如，指针为 NULL 表示没有值）
  结构体间的聚合关系 通过指针，可以实现结构体之间的聚合关系，例如链表、树等数据结构，结构体之间的聚合关系是一种常见的设计模式，它允许一个结构体包含另一个结构体的实例或指针。这种关系可以通过指针来实现，使得不同结构体能够协同工作，彼此引用，从而构建更复杂的数据结构和系统
  回调（使用指向函数的指针）函数指针可以用来实现回调机制，使得函数的行为可以在运行时灵活变化
  泛型接口（使用指向 void 的指针）void 指针可以指向任何类型的数据，常用于实现泛型接口

  1、指向对象的指针
  对象指针初始化 指向对象的指针可以通过应用于对象类型（可以不完整）表达式的取址运算符初始化，即指针初始化可以通过应用于对象类型表达式的取址运算符来初始化指向对象的指针
  * 一元运算符(对象) 指针可以出现作为间接运算符（一元 *）的操作数，它返回标识所指向对象的左值，即在 C 语言中，指针可以通过间接运算符（即一元 *）来访问它所指向的对象，可以通过这种方式对指针所指向的对象进行读取和修改操作，指针在操作内存和变量时使得我们能够通过指针间接访问和操作变量的值
  -> 运算符(结构体联合体) 指向结构体和联合体类型的对象的指针亦可作为经由指针的成员访问运算符 -> 的左操作数出现，在 C 语言中，当我们使用指针指向结构体或联合体类型的对象时，可以通过箭头运算符 -> 来访问结构体或联合体的成员。这种运算符的使用简化了指针操作，使得代码更加易读
  隐式转换算术运算(数组) 因为数组到指针具有隐式转换，指向数组首元素的指针可通过数组类型表达式初始化，有一些加法、减法、复合赋值、自增和自减运算符对指向数组元素的指针有定义，在 C 语言中，数组名在大多数表达式中会被隐式转换为指向其第一个元素的指针。这使得我们可以方便地通过数组名来初始化指向数组元素的指针。此外，指向数组元素的指针也可以进行一些指针运算，如加法、减法、自增和自减运算等
  指针比较运算符 比较运算符在一些情况下对指向对象的指针有定义：两个表示相同地址的指针比较相等，两个空指针值比较相等，比较指向同一数组的元素的指针以两个元素的数组下标进行比较，以及指向结构体成员的指针以这些成员的声明顺序进行比较，许多实现亦提供对任意来源指针的严格全序，例如若它们实现在连续（“平直”）的虚拟地址空间上，关键点 比较相同地址的指针、空指针比较、指向同一数组的指针比较、指向结构体成员的指针比较、任意来源指针的严格全序
   
  2、指向函数的指针
  函数的指针初始化 指向函数的指针可由函数地址初始化。因为函数到指针转换，取址运算符是可选的
  函数传递 不同于函数，指向函数的指针是对象，从而能存储在数组中，被复制、赋值，作为参数传递给其他函数等等
  函数指针调用 指向函数的指针可以用作函数调用运算符的左操作数；这会调用所指向的函数，即指向函数的指针可以用作函数调用运算符 () 的左操作数，这意味着你可以通过函数指针来调用它所指向的函数，函数指针的定义：函数指针是一个指向函数的指针。它可以存储函数的地址，从而可以通过这个指针来调用函数、用函数指针调用函数：当一个函数指针指向一个函数后，可以像普通函数一样使用函数调用运算符 () 来调用这个函数
  解引用 对函数指针进行解引用会得到所指向函数的函数指示符
  函数比较 相等性比较运算符定义于指向函数的指针（若指向相同函数则它们比较相等）因为函数类型的兼容性忽略函数形参的顶层限定符，指向仅在形参的顶层限定符有区别的函数指针是可互换的，即在 C 语言中，函数指针可以用来指向函数，并且可以通过比较运算符来判断两个函数指针是否指向同一个函数。此外，函数类型的兼容性规则会忽略函数形参的顶层限定符（如 const 和 volatile），因此这些限定符不会影响函数指针的比较和互换性
  
  3、指向 void 类型的指针
  指向任意类型对象的指针能隐式转换成指向 void 的指针（可选地有 const 或 volatile 限定），反之亦然
  指向 void 的指针用于传递未知类型的对象，这在泛型接口中常用：malloc 返回 void*，qsort 期待用户提供接受两个 const void* 实参的回调。pthread_create 期待用户提供接受并返回 void* 的回调。所有情况下，调用方负责在使用前将指针转换到正确的类型，即在 C 语言中，void* 类型的指针是一种通用指针类型，可以指向任何类型的对象。这使得 void* 非常适合用于泛型接口，例如内存分配、排序函数和多线程编程
  
  4、空指针
  每种类型的指针都有一个特殊的值，称为该类型的 “空指针值”。值为 null 的指针不指向任何对象或函数（解引用空指针是未定义行为），并且与同一类型值也为 null 的所有指针比较相等
  要将指针初始化为 null 或者将 null 值赋给已有的指针，可以使用空指针常量（如 “NULL” 或者任何其他值为零的整数常量）。“静态初始化” 也会将指针初始化为它们的 null 值
  空指针可以表示对象不存在，也可以用于表示其他类型的错误情况。通常，接收指针参数的函数几乎总是需要检查该值是否为空，并以不同的方式处理这种情况（例如，当传递空指针时，free不执行任何操作）

  5、在 C 语言中，指针和类型转换涉及许多复杂的规则和未定义行为
  严格别名规则 严格别名规则规定，解引用一个指针时，如果该指针的类型与对象的声明类型不同，则几乎总是会导致未定义行为。这是为了优化编译器的代码生成
  restrict 关键字 restrict 关键字是在 C99 中引入的，用于指示一个指针是唯一访问某一块内存的手段。这意味着通过该指针访问的内存不会被其他指针别名，从而允许编译器进行更多的优化
  数组到指针的转换 在大多数情况下，数组类型的左值表达式会隐式转换成指向数组首元素的指针。这个转换称为“数组到指针转换” 个别情况见 arrays.c 说明
  指针指向char类型 在 C 语言中，指向 char 类型的指针通常用于表示字符串。字符串是以 '\0'（空字符）结尾的 char 数组。为了表示合法的字符串，指针必须指向 char 数组的元素，并且数组中必须有一个或多个 '\0' 字符以示字符串的结束
  */
  float *p;            // 简单指向对象的指针 类型说明符序列 float 说明指针 p 指向 float 类型的对象、声明符 *p 表示 p 是一个指针，指向 float 类型
  float **pp;          // 指向指针的指针 类型说明符序列 float 说明指针 pp 指向的是一个指向 float 类型对象的指针、声明符 **pp 表示 pp 是一个指向指针的指针，而这个指针指向 float 类型
  int (*fp)(int);      // 指向函数的指针 类型说明符序列 int 说明 fp 最终指向的函数返回 int 类型、声明符 (*fp)(int) 表示 fp 是一个指向函数的指针，这个函数接受一个 int 参数，返回 int 类型
  // int* fn(int);     // 返回指针的函数 类型说明符序列 int*，表示返回一个指向 int 的指针、声明符 fn(int) 表示 fn 是一个函数，这个函数接受一个 int 参数，并返回一个 int* 类型的值
  const int *pc;       // 带限定符的指针 pc 是一个指向 const int 的指针，这意味着通过 pc 不能修改它所指向的 int 值
  int * const cp;      // 带限定符的指针 cp 是一个 const 指针，指向一个 int，这意味着 cp 本身不能指向其他地址，但可以修改它所指向的 int 值
  int * const * pcp;   // 带限定符的指针 pcp 是一个指向 const 指针（该指针指向 int）的指针，这意味着 pcp 可以修改所指向的 const 指针
  // [[deprecated]] int *ptr; // 带属性说明符序列的指针(C23起) ptr 是一个指针，指向 int，并且标记为 deprecated

  int *nnp;            // 1、指向对象的指针
  int *const *nnpp;
  int ** const nnpp1;
  int (*arrp)[2];
  int (*ele)[3][3]; 
  struct S { int n; } s = {1};
  struct S* ssp;

  void (*pf1)(int);    // 2、指向函数的指针                       

  int nv = 1, *pv=&nv; // 3、指向 void 类型的指针
  void* pvv = pv;
  int* pv2 = pvv;
  void* thread_function(void *arg);

  int *nup1 = NULL;    // 4、空指针
  int *nup2 = 0;
  static int *nup3;

  int az = 42;         // 5、指针注解         
  float *pz = (float *)&az;
  int resa[] = {1, 2, 3, 4, 5};
  int *restrict resap = resa;
  int arrays[5] = {1, 2, 3, 4, 5};        
  int *arraysp = arrays;
  char str1p[] = "Hello, World!";                    
  char str2p[] = {'H', 'e', 'l', 'l', 'o', '\0'};    
  char *str1p1 = str1p;                              
  char *str2p2 = str2p;

  /*
  数组，详情移至 arrays.c 文档
  数组是由连续无空隙分配的，拥有特定元素类型的对象构成的。这些对象的数目数量（数组大小）在数组生存期间决不改变
  在数组声明的声明语法中，类型说明符的序列指定元素类型（必须是一个完整对象类型如 int、char），声明符 的形式为 [10]、[restrict 10]
  一般的数组 声明符 的语法
  [static(可选) 限定符(可选) 表达式(可选)] 属性说明符序列(可选)
  [限定符(可选) static(可选) 表达式(可选)] 属性说明符序列(可选)
  未指定大小的 VLA 的声明符（只能出现于函数原型作用域）
  [限定符(可选) * ] 属性说明符序列(可选) 
  表达式 任何无逗号运算符的表达式，表明数组中的元素数量
  限定符 const、restrict 和 volatile 限定符的任意混合，只允许出现于函数形参列表中，它们对数组形参所转换得到的指针类型赋予限定
  属性说明符序列	(C23起)可选的属性列表，应用到被声明的数组

  基本声明形式：int arr[10];，声明一个包含 10 个 int 的数组
  带 const 限定符：void foo(const int arr[10]); 声明一个参数不能修改的数组
  带 static 关键字：void bar(int arr[static 10]); 提示编译器数组至少有 10 个元素
  带 restrict 限定符：void baz(int arr[restrict 10]); 提示编译器优化指针访问
  未指定大小的 VLA：void qux(int n, int arr[n][*]); 声明一个可变长度数组
  属性说明符序列：void fun(int arr[10] [[deprecated]]); 向编译器传达额外信息 

  数组类型有几种变体：已知常量大小的数组、变长度数组，以及未知大小数组
  1、已知常量大小数组 若数组声明符中的 表达式 为整数常量表达式，拥有大于零的值，且元素类型是一种拥有已知常量大小的类型（即元素不是VLA） (C99起)，则声明符声明的是已知常量大小的数组，
  已知常量大小的数组可以用数组初始化器提供它们的初始值
  在函数形参列表中，数组声明符中允许有额外的语法元素：关键词 static 及 限定符，它们可以以任意顺序在大小表达式之前出现（即便省略大小表达式也可以出现它们）
  对于函数中在数组形参的 [ 和 ] 中使用关键词 static 的情况，每次对这种函数函数调用中，实际参数的值必须是一个指向数组首地址的合法指针，该数组至少有 表达式 所指定的元素数目
  若存在 限定符，则它们对数组参数类型所转换得的指针类型赋予限定，在 C 语言中，当函数参数是数组时，在实际传递过程中，数组会自动转换为指向其首元素的指针类型。如果在这个数组参数的声明中存在限定符（比如 const、volatile 等），那么这些限定符会对转换后得到的指针类型施加相应的限定作用

  2、变长度数组 非常量长度数组 若 表达式 不是整数常量表达式，则数组声明器声明一个非常量大小的数组（VLA）
  变长数组（VLA, Variable Length Array）和变长修改类型（VM, Variable Modified type）有一些特定的限制和要求，变长数组 (VLA): 数组的大小在编译时未知，而在运行时确定的数组、变长修改类型 (VM): 包含VLA或者指向VLA的指针的类型
  每次控制流经过该声明时，会求值 表达式（而且它必须每次求值为大于零的值），然后分配数组（对应地，VLA 的生存期在其声明离开作用域时结束）。VLA 实例的大小不会在其生存期中改变，但在另一次经过同一代码时，它可能被分配不同大小
  若大小是 * ，则声明是对于未指定大小的 VLA 的。这种声明只能出现于函数原型作用域，并声明一个完整类型的数组。其实，所有函数原型作用域中的 VLA 声明符都被处理成如同用 * 替换 表达式
  变长数组 非常量长度数组与从它们派生的类型（指向它们的指针，等等）被通称为“可变修改类型”（VM）。任何可变修改类型的对象只能声明于块作用域或函数原型作用域中
  VLA 必须拥有自动或分配存储期，指向 VLA 的指针但不是 VLA 自身亦可拥有静态存储期，VM 类型不能拥有链接
  变长数组 可变修改的类型不能是结构体或联合体的成员，变长数组和变长修改类型不能作为结构体或联合体的成员。原因在于结构体和联合体的大小在编译时必须是确定的，而VLA的大小在编译时是未知的
  C标准允许编译器定义一个宏常量 __STDC_NO_VLA__ 来指示是否支持VLA和VM类型：C99标准: 如果定义为1，表示编译器不支持VLA和VM类型、C11标准（到C23前）: 如果定义为1，表示编译器不支持具有自动存储期的VLA对象，但仍必须支持分配存储期的VLA对象

  3、未知大小数组 若忽略数组声明器中的 表达式，则它声明一个未知大小数组。
  除了函数形参列表中的情况（这种数组被转换成指针），以及有初始化器的情况之外，这种类型都是不完整类型（注意，以 * 代替大小声明的拥有未指定大小的 VLA 是完整类型） (C99起)
  在 struct 定义中，未知大小数组可以作为最后一个元素出现（只要有至少一个其他具名成员），这种情况下，这是称为柔性数组成员的特殊情形。细节见 structure.c 文档

  4、限定符 在C99及以后的标准中，如果数组类型声明中有 const、volatile 或 restrict 限定符，这些限定符实际上应用于数组的元素类型，而不是数组类型本身。这可以通过使用 typedef 来实现
  在C23之前的标准中，数组类型被认为与其元素类型具有相同的限定符。这意味着数组类型本身没有 const、volatile 或 restrict 限定符，只是其元素类型具有这些限定符
  在C23标准中，对数组类型的处理更为严格，数组类型本身被认为具有这些限定符。如果一个数组是 const 的，那么这个数组类型也被认为是 const 的，因此不允许将 const 数组类型转换为 void* 指针
  在C标准中，不允许直接将 _Atomic 限定符应用于数组类型，但允许数组的元素类型是原子类型

  5、赋值 数组类型的对象不是可修改左值，尽管它们可以取地址，但它们不能出现于赋值运算符的左侧。不过，拥有数组成员的结构体是可修改左值，并可以赋值
  在C语言中，数组名本身不是可修改左值。这意味着你不能直接对一个数组整体进行赋值操作。数组名在表达式中通常会被转换为指向其第一个元素的指针，但它不能出现在赋值运算符的左侧
  结构体是可修改左值: 与数组不同，结构体类型的对象是可修改左值。这意味着你可以对结构体整体进行赋值操作。即使一个结构体包含数组成员，结构体整体仍然是可修改的，这是因为结构体在C语言中的定义允许对整个结构体对象进行操作，包括赋值、传递和返回。这些操作会触发对结构体中所有成员（包括数组成员）进行逐成员的赋值或拷贝

  6、数组到指针转换 在C语言中，数组到指针的隐式转换是一种常见的操作。这个转换在特定的上下文中会自动发生，将数组类型的左值表达式转换为指向其第一个元素的指针。这种转换的结果是一个非左值指针，可以用于指向数组的元素
  隐式转换的上下文不会转换为指针的情况：作为取地址运算符（&）的操作数、作为 sizeof 运算符的操作数、作为 typeof 和 typeof_unqual 的操作数（C23起）、作为用于数组初始化的字符串字面量、作为 _Alignof 的操作数（C11起）
  数组类型的左值表达式会隐式转换为指向其首元素的指针：函数参数、表达式中的操作数
  当数组类型用于函数形参列表时，它会转换成对应的指针类型： int f(int a[2]) 和 int f(int* a) 声明同一个函数。因为函数实际参数类型为指针类型，使用数组实参的函数调用会进行一个数组到指针转换；被调用函数无法获得实参数组的大小，所以必须显式传递size  

  7、多维数组 当数组的元素是另一个数组时，我们称数组是多维的
  当用数组到指针转换时，多维数组被转换成指向其首元素的指针，例如指向首行的指针
  若支持 VLA 则 (C11 起)多维数组可以在每一维度可变修改，允许数组的每一维度在运行时动态确定大小。例如，int am2[nm][2*nm] 是一个二维VLA数组，大小在运行时由 nm 决定

  8、零长度数组 在C语言标准中，不允许声明零长度数组。这意味着你不能定义一个长度为零的数组
  一些编译器（特别是C99标准之前）提供零长度数组作为扩展，典型用例是实现柔性数组成员（FAM）。柔性数组成员在结构体中用于定义可变长度的最后一个数组成员

  9、副作用
  可变长度数组（VLA）VLA 是C99引入的一种特性，允许数组的大小在运行时确定，而不是编译时
  大小表达式的副作用：如果VLA的大小表达式中包含副作用，编译器保证这些副作用将正确产生。副作用是指表达式在求值过程中对程序状态的改变，例如++（递增）操作符
  */
  float cats[11], *dogs[17];       // cats 是 11 个 float 组成的数组，dogs 是 17 个指向 float 的指针组成的数组
  const int arrc[10];              // 这声明了一个长度为 10 的 const int 数组 arrc，数组中的元素是常量，这意味着一旦初始化后，其元素值不能被修改
  static int arrs[10];             // 如果声明在函数外 static 关键字使得这个数组的作用域被限制在声明它的文件中（文件作用域），但其生命周期是整个程序运行期间、如果声明在函数内：static 关键字使得数组在函数的多次调用间保持其值（静态局部变量）
  // int arrr[restrict 10];        // 非法 限定符 const、restrict 和 volatile 限定符的任意混合，只允许出现于函数形参列表中，它们对数组形参所转换得到的指针类型赋予限定
  // int arrvla[10][*];            // 非法 若大小是 * ，则声明是对于未指定大小的 VLA 的。这种声明只能出现于函数原型作用域，并声明一个完整类型的数组
  void fool(int arrc[const 10]);
  void bar(int arrs[static 10]);
  void baz(int arrr[restrict 10]);
  void qux(int n, int arrvla[n][*]);

  int n[10];                      // 1、整数常量是常量表达式
  char o[sizeof(double)];         // sizeof 是常量表达式
  enum { MAX_SZ=100 };
  int nea[MAX_SZ];                // 枚举常量是常量表达式
  int arra[5] = {1,2,3};          // 声明 int[5] 数组 且初始化为 1,2,3,0,0
  char str[] = "abc";             // 声明 char[4] 数组 且初始化为 'a','b','c','\0'
  double fa[10] = {0}, fb[20] = {0};
  const int arrct[] = {0, 1, 2, 3}; // 等价于 const int * arrct; 数组作为参数传递时会退化为指针
  volatile int arrvl[] = {0, 1, 2, 3}; // 等价于 volatile int * arrxl; 数组作为参数传递时会退化为指针
  // restrict int arrrt[10];        // 非法 restrict 只能用于指针，而不能直接用于数组声明，int arrrt[10]; int *restrict p = arrrt; // p 是一个指向数组 arrr 的 restrict 指针

  int n1 = 3;                       // 2、变长数组
  int A[n1];                        // 变长数组 可变修改类型的对象声明于块作用域
  int (*p2)[n1];                    // 变长数组指针 可变修改类型的对象声明于块作用域
  void fvla(int m, int C[m][m]);    // 变长数组指针 可变修改类型的对象声明于函数原型作用域
  void quB(int n, int ala[n][*]);   // 变长数组指针 可变修改类型的对象声明于函数原型作用域
  int arrvla[n1];                   // arr 是一个 VLA，具有自动存储期
  int *arrn = malloc(n1 * sizeof(int)); // arrn 是一个 VLA，由 molloc 分配，动态分配内存
  // static int arr[n1];                // 这是不合法的，VLA 不能具有静态存储期，尝试声明一个静态VLA
  int *static_pointer = arr;            // 静态指针指向 VLA，指针具有静态存储期，VLA具有自动存储期
  // struct tag {                       // 可变修改的类型不能是结构体或联合体的成员
  //   int z[n1];                       // 错误： VLA 结构体成员
  //   int (*y)[n1];                    // 错误： VM 结构体成员
  // }; 

  extern int x[];                // 3、未知大小的数组 x 的类型是“边界未知的 int 数组”
  int aun[] = {1,2,3};           // a 的类型是“3 个 int 的数组”
  struct s {int n; double d[];}; // s.d 是柔性数组成员
  struct s *s1 = malloc(sizeof (struct s) + (sizeof (double) * 8)); // 如同 d 是 double d[8]

  typedef int cA[2][3];                         // 4、在这个例子中，typedef 定义了一个二维数组类型 cA。当我们声明 const cA ca 时，实际上我们声明的是一个二维数组，其元素类型是 const int。因此，ca[0] 的类型是 const int*，而不是 int*，这就是为什么尝试将 ca[0] 赋值给 int* 指针 pi 会产生错误
  const cA ca = {{4, 5, 6}, {7, 8, 9}};         // const int 的数组的数组
  int* cpi = ca[0];                             // ca[0] 类型为 const int*
  void *unqual_ptr = ca;                        // C23 前 OK；C23 起错误 C23之前，将一个 const 数组类型转换为 void* 是合法的，因为数组类型本身没有 const 限定符，仅其元素类型有、在C23标准下，这个转换将被视为错误，因为 ca 是一个 const 数组类型，不能转换为一个未限定的 void* 指针
  typedef int tA[2];
  // _Atomic tA ta0 = {0};    // 错误，_Atomic tA ta0 和 _Atomic(tA) ta1 是错误的，因为 _Atomic 不能应用于数组类型
  // _Atomic(tA) ta1 = {0};   // 错误，_Atomic tA ta0 和 _Atomic(tA) ta1 是错误的，因为 _Atomic 不能应用于数组类型
  _Atomic int ta2[2] = {0};  // OK，_Atomic int ta2[2] 和 _Atomic(int) ta3[2] 是合法的，因为它们声明了一个数组，其元素类型是 _Atomic int
  _Atomic(int) ta3[2] = {0}; // OK，_Atomic int ta2[2] 和 _Atomic(int) ta3[2] 是合法的，因为它们声明了一个数组，其元素类型是 _Atomic int

  int aq[3] = {1, 2, 3}, bq[3] = {4, 5, 6};     // 5、赋值
  int arrq[5];
  int *pq = arrq;                               // 合法，arrq 被转换为指向其第一个元素的指针
  // arrq = {1, 2, 3, 4, 5};                    // 错误，不能对数组整体赋值
  int (*pq1)[3] = &aq;                          // OK，可以取地址
  // aq = bq;                                   // 错误，aq 是数组
  struct { int cq[3]; } sq1, sq2 = {3,4,5};
  sq1 = sq2;                                    // OK：可以对拥有数组成员的结构体赋值

  int arrcs[5];                     // 6、数组到指针的转换
  int (*pcs)[5] = &arrcs;           // pcs 是指向数组的指针，当数组作为 & 运算符的操作数时，得到的是数组的地址，而不是数组首元素的指针
  size_t sizecs = sizeof(arrcs);    // sizecs 是数组的大小，单位是字节，当数组作为 sizeof 运算符的操作数时，得到的是数组的大小，而不是指向数组首元素的指针
  typeof(arrcs) another_arrcs;      // another_arrcs 是与 arrcs 类型相同的数组，typeof 和 typeof_unqual 运算符会获得数组的真实类型，而不是进行隐式转换，需要 C23 支持，假设 typeof 是可用的
  char strcs[] = "hello";           // strcs 是字符数组，包含字符串 "hello" 和结尾的 '\0'，字符串字面量用于初始化字符数组时，不会发生隐式转换
  size_t aligncs = _Alignof(arrcs); // aligncs 是数组的对齐要求，_Alignof 运算符会获得数组的对齐要求，而不是进行隐式转换  
  register int rarr[5];             // register 修饰符和数组 如果声明一个数组为 register，则尝试对该数组取地址的行为是未定义的。这是因为 register 修饰符建议编译器将变量存储在寄存器中，而不是内存中，数组通常不适合存储在寄存器中，这是因为 register 修饰符和数组的存储需求冲突，编译器无法保证将数组存储在寄存器中
  // int *rp = &rarr;               // 错误：行为未定义，不能取 `register` 数组的地址  

  int a1[2] = {1, 2};                    // 7、一维数组 元素个数 1，2
  int *pm0 = a1;                         // 指向一维数组的首元素
  int am[2][3] = {{1,2,3}, {4,5,6}};     // 二维数组 2x3 矩阵（2 个元素的数组，每个元素为 3 个 int 的数组）可视作行主导排列的 2x3 矩阵
  int (*pm1)[3] = am;                    // 指向首个 3 个元素行的指针、pm1 是一个指向包含3个整数的数组的指针、am 被隐式转换为指向它的首行的指针，即 int (*)[3] 类型
  int bm[3][3][3];                       // 三维数组 3x3x3 立方体
  int (*pm2)[3][3] = bm;                 // 指向首个 3x3 平面的指针 、pm2 是一个指向 3x3 二维平面的指针、bm 被隐式转换为指向其首个 3x3 平面的指针，即 int (*)[3][3] 类型
  int nm = 10;
  int am2[nm][2*nm];                     // 若支持 VLA 则 (C11起)多维数组可以在每一维度可变修改

  int arrv[0];    // 8、这是非法的，标准C语言不允许声明零长度数组
  struct Sts {    // C99及以后的标准：引入了柔性数组成员的标准语法
    int n;
    int arr[];    // 柔性数组成员，允许在定义结构体时不指定数组大小
  };

  int nval = 5;
  int narrvl[nv];                               // 9、合法的VLA语法，数组大小由变量nv决定
  int nv1 = 5, mv1 = 5;
  size_t szv1 = sizeof(int (*[nv1++])[mv1++]);  // nv1 和 mv1 作为数组大小表达式的一部分，int (*[nv1++])[mv1++]：这是一个指向大小为mv1++的数组的指针数组，其大小为nv1++、sizeof 操作符：计算表达式的大小，而不实际创建该类型的对象，副作用保证：C标准保证在上述表达式中nv1会被自增，mv1也会被自增，但在某些情况下（如sizeof操作的结果不依赖副效应时），mv1可能不会被自增，具体行为：语句执行后，nv1一定会增加1，而mv1可能增加也可能不增加，这取决于编译器的实现和优化

  /*
  枚举类型 enum，详细见 enumerated.c 文档
  */

  /*
  struct，详细见 structure.c 文档
  */

  /*
  union，详细见 unions.c 文档
  */

  /*
  位域
  */

  /*
  原子类型(C11)，详细见 atomics.c 文档
  */

  /* 
  const
  volatile
  restrict(C99)
  
  对齐说明符(C11)
  
  存储期与链接

  外部及试探性定义
  
  typedef
  
  静态断言(C11)
  
  属性(C23)  
  */
  print_purple("declaration start...\n");

#endif // DECLARATIONS declarations 声明

  return 0;  
}