/**
* @file              initialization.c
* @brief             初始化对象声明可以通过名为初始化的步骤提供其初始值
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.02
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.02 <td>0.1             <td>brightl         <td>初始化方式、特性
* </table>
*/

#include "c/variable/variable.h"
#include <stdio.h>
#include <stdlib.h>
#include <threads.h>
#include <stdbool.h>

/**
* @brief             对象声明可以通过名为初始化的步骤提供其初始值
*
* @note              对于每个声明符，若不省略初始化式，则它可以是下列之一：= 表达式、= {初始化式列表}、= {}	
*/
#define INITIALIZATION
// 初始化

// 显式初始化
// 隐式初始化
// 空初始化

// 标量初始化

// 数组初始化

// 结构体及联合体初始化

int global_var;                                 // 静态存储期，隐式初始化为0
_Thread_local int thread_local_global_var = 0;  // 文件作用域的变量，_Thread_local变量，隐式初始化为0
int globalVar = 5;

/**
* @brief             对象声明可以通过名为初始化的步骤提供其初始值
* @return  int       Return Description
*
* @note              初始化式指定存储于一个对象中的初始值
*/
int initialization_fn(void) {
#ifdef INITIALIZATION
  /*
  初始化 对象声明可以通过名为初始化的步骤提供其初始值
  解释 初始化式指定存储于一个对象中的初始值

  1、对于每个声明符，若不省略初始化式，则它可以是下列之一
  = 表达式	         (1)	
  = { 初始化式列表 }	(2)	
  = { }	            (3)	(C23起)
  其中 “初始化式列表” 是非空的逗号分隔 ”初始化式“ 列表（尾逗号可选），这里每个初始化式拥有三种可能形式之一
  表达式	           (1)	
  { 初始化器列表 }	  (2)
  { }	              (3)	(C23起)
  指派符列表 = 初始化式	(4)	(C99起) 其中 指派符列表 是形式为 [ 常量表达式 ] 的数组指派符的列表，或形式为 . 标识符 的结构体/联合体指派符的列表；见数组初始化和结构体初始化
  
  2、注意：除了初始化器，花括号环绕的 初始化器列表 亦可出现于复合字面量中，它是有下列形式的表达式
  (类型) { 初始化器列表 }
  (类型) { }		        (C23 起)
  复合字面量指构造一个指定类型的无名对象，在只需要一次数组、结构体或联合体变量时使用
  int *array = (int[]) {1, 2, 3, 4, 5}; (int[]) {1, 2, 3, 4, 5} 创建了一个匿名的整数数组，并将其初始化为 {1, 2, 3, 4, 5}。这个数组的地址被赋值给指针 array
  复合字面量在C语言中有许多实际应用，比如 传递临时对象：可以在函数调用时传递临时创建的对象、简化代码：避免定义临时变量，直接在表达式中创建和初始化对象、设置默认值：使用空初始化器列表设置默认值（C23起）
  */
  print_purple("initialization start...\n");
  int a = 5;                      // 1、直接赋值，= 表达式 这是最常见的初始化形式，直接赋值一个表达式的计算结果给变量
  float b = 3.14;                 // 直接赋值
  char c = 'A';                   // 直接赋值
  int array[3] = {1, 2, 3};       // 初始化数组，= { 初始化器列表 } 对于数组、结构体、联合体，可以使用花括号 {} 包围的初始化器列表进行初始化。初始化器列表是一个非空的、以逗号分隔的表达式列表。尾逗号是可选的
  struct Point { int x; int y; };
  struct Point p = {10, 20};      // 初始化结构体 
  int arrayk[3] = { };            // 数组所有元素初始化为0 (C23起)，= { } (C23起) 从C23标准开始，允许使用空的花括号 {} 进行默认初始化。这种形式将所有成员或元素初始化为零或默认值
  struct Point pk = { };          // 结构体所有成员初始化为0 (C23起)
  int arrayz[5] = { [0] = 1, [2] = 2, [4] = 3 };  // 使用指派符初始化，指派符列表 = 初始化式 (C99起) 从C99标准开始，C语言引入了指派符（designator）语法，允许精确地初始化结构体或数组的特定成员或元素
  struct Point pz = { .x = 10, .y = 20 };         // 使用指派符初始化

  int *arrayf = (int[]) {1, 2, 3, 4, 5};          // 2、(struct Point) { .x = 10, .y = 20 } 创建了一个匿名的 struct Point 对象并将其初始化。这个对象被赋值给变量 p
  struct Point pf = (struct Point) { };           // (struct Point) { } 创建了一个匿名的 struct Point 对象，并将其默认初始化为零（即所有成员都为零）  

  /*
  显式初始化，即显式初始化是指在声明变量时直接为其提供一个初始值。根据变量的类型，显式初始化的方式有所不同
  若提供了“初始化式”，对于
  标量类型初始化，见标量初始化，标量类型包括基本类型（如int、float、char等）。显式初始化时直接赋值一个表达式给变量
  数组类型初始化，见数组初始化，数组类型的显式初始化使用花括号 {} 包围的初始化器列表
  结构体及联合体类型初始化，见结构体初始化，结构体和联合体类型的显式初始化也使用花括号 {} 包围的初始化器列表
  */
  int ab = 10;          // 标量类型初始化
  float bb = 3.14;      // 标量类型初始化
  char cb = 'A';        // 标量类型初始化  
  int arrayb[3] = {1, 2, 3};    // 数组类型初始化
  char strb[] = "Hello";        // 字符数组初始化（自动加上终止符 '\0'）
  struct Point pb = {10, 20};   // 结构体初始化
  /*
  隐式初始化，即隐式初始化是指在声明变量时未提供初始值。根据变量的存储期（storage duration），未初始化的变量会有不同的默认值
  若未提供”初始化式“
  拥有自动存储期的对象将被初始化为不确定值（可能是陷阱表示）
  拥有静态及线程局域存储期的对象被空初始化，即拥有静态存储期（static storage duration）或线程局域存储期（thread-local storage duration）的对象未显式初始化时，将被隐式初始化为零值

  自动存储期 拥有自动存储期（automatic storage duration，即局部变量，但不包括静态局部变量）的对象未显式初始化时，其值是不确定的，可能是垃圾值或陷阱表示
  静态存储期的对象 全局变量和使用 static 关键字声明的局部变量
  线程局域存储期的对象 使用 _Thread_local 关键字声明
  */
  int var;                                        // 局部变量自动存储期，其值是不确定的
  static int static_var;                          // 静态存储期，隐式初始化为0
  static _Thread_local int thread_local_var = 0;  // 函数内部的静态变量，线程局域存储期，隐式初始化为0
  print_purple("storage uninitialized int: %d\n", var);
  print_purple("Static storage uninitialized int: %d\n", static_var);
  print_purple("Static storage Thread-local storage uninitialized int: %d\n", thread_local_var);
  print_purple("Global uninitialized int: %d\n", global_var);
  print_purple("Global uninitialized _Thread_local int: %d\n", thread_local_global_var);
  /*
  空初始化
  若显式以初始化式 = {} 初始化对象，则它被空初始化 (C23起)

  一些情况下，若未显式初始化对象则它被空初始化，即
  指针被初始化成其类型的空指针值
  整数类型对象被初始化成无符号的零
  浮点类型对象被初始化成正零
  数组的所有元素、结构体的所有成员及联合体的首个成员递归地空初始化，外加将所有填充位初始化为零
  
  在空指针值和浮点零拥有全零位表示的平台上，静态对象的这种初始化形式普遍以将其分配到程序映像的 .bss 段来实现，
  即在许多平台上，静态对象（包括全局变量和静态局部变量）的空初始化通常通过将它们分配到程序映像的 .bss 段来实现。.bss 段（Block Started by Symbol）是一种存储未初始化的静态变量的内存区域。程序加载时，操作系统会将 .bss 段中的所有位置初始化为零
  静态对象的空初始化通常通过将它们分配到 .bss 段实现，程序加载时操作系统会自动将 .bss 段清零
  */
  int arraykx[] = { };            // 显式初始化式 = {} 初始化对象
  struct Point pkx = { };         // 显式初始化式 = {} 初始化对象
  static int *ptr;                       // 指针类型的变量未显式初始化时，它们会被初始化为“空指针值”（null pointer value）。空指针值对于任何指针类型都是相同的，用常量NULL表示
  if (ptr == NULL) {
    print_purple("Pointer is null.\n");
  }
  static int i;                          // 整数类型的变量未显式初始化时，它们会被初始化为零。对于无符号整数类型，这意味着初始化为无符号的零值
  static unsigned int u;
  print_purple("i: %d, u: %u\n", i, u);
  static float f;                        // 浮点类型的变量未显式初始化时，它们会被初始化为正零
  static double d;                       
  print_purple("f: %f, d: %f\n", f, d);
  static int arr[5];                     // 数组类型的变量未显式初始化时，数组的所有元素都会被递归地空初始化，即每个元素都被初始化为其类型的零值
  for (int i = 0; i < 5; i++) {
    print_purple("arr[%d]: %d\n", i, arr[i]);
  }
  static struct Point ps;                // 结构体和联合体类型的变量未显式初始化时，结构体的所有成员和联合体的首个成员都会被递归地空初始化，同时所有填充位也会被初始化为零
  print_purple("Point: x=%d, y=%d\n", ps.x, ps.y);  

  /*
  初始化注解
  1、在初始化静态或线程局域存储期的对象时，每个初始化式中的 表达式 都必须是常量表达式或字符串字面量，即在C语言中，静态存储期（static storage duration）和线程局域存储期（thread-local storage duration）的对象在初始化时，每个初始化式中的表达式都必须是常量表达式或字符串字面量。这一要求确保了这些对象在程序加载或线程启动时，可以被正确地初始化，因为它们的初始化值在编译时就已经确定
  相关存储期的对象
  静态存储期：包括全局作用域的变量和使用static关键字声明的局部变量，这些变量在程序的整个运行期间存在
  线程局域存储期：包括使用_Thread_local关键字声明的变量，这些变量在每个线程中都有独立的实例，并且在整个线程的生命周期内存在
  常量表达式 常量表达式是编译时就能求值的表达式，它们的值在编译阶段已经确定，不依赖于程序运行时的状态。常量表达式通常包括常量、枚举常量以及这些值经过编译时计算的结果
  字符串字面量 字符串字面量是用双引号括起来的一串字符，它们在编译时确定，并存储在程序的只读数据区中

  2、初始化式不能用于不完整类型的对象、VLA 及拥有链接的块作用域对象
  不完整类型（incomplete type）是指在声明时其大小未知的类型。例如，前向声明的结构体或联合体，以及未定义大小的数组。在这种情况下，编译器无法为对象分配内存，因此无法进行初始化
  可变长度数组（Variable Length Array, VLA）是在块作用域内声明的数组，其大小在运行时确定。由于VLA的大小在编译时未知，初始化式不能用于VLA
  具有链接的块作用域对象：根据C标准，具有外部链接的对象通常在翻译单元的其他地方定义和初始化。块作用域内的extern声明仅用于引用外部定义，不能在块作用域内同时进行定义和初始化
  不完整类型：不能为不完整类型（例如前向声明的结构体或未定义大小的数组）提供初始化式。
  可变长度数组（VLA）：不能为在块作用域内声明的可变长度数组提供初始化式。
  
  具有链接属性的块作用域对象：不能在块作用域内为具有链接属性（extern或static）的对象提供初始化式  
  块作用域对象是指在函数或代码块（例如，if语句、while循环、for循环等）内声明的变量。链接属性（linkage attributes）指的是变量的可见性和生存期属性，包括extern和static关键字
  链接属性和初始化的限制
  extern关键字：用于声明一个外部变量，这个变量在其他翻译单元中定义。使用extern声明的变量不能在块作用域内进行初始化，因为extern声明只是告诉编译器这个变量在别处定义
  static关键字：用于声明一个静态局部变量，这个变量在整个程序生命周期内存在，但其作用域仅限于声明它的函数或代码块。static局部变量在块作用域内可以初始化，但如果它在全局作用域内声明，则不能在extern关键字中初始化  
  
  3、函数形参的初值如同用从函数调用实参赋值，而非初始化一样建立
  在C语言中，函数形参的初值（即函数参数的值）是通过函数调用时传递的实参进行赋值的，而不是像变量初始化那样建立。这意味着形参在函数调用时获得其初始值，而不是在函数定义时
  赋值 vs 初始化
  初始化：在变量声明的同时赋予初始值。例如 int x = 10;  // 这是初始化
  赋值：在变量声明之后，给变量赋值。例如 int x; x = 10;  // 这是赋值
  
  函数形参赋值的过程 当函数被调用时，传递给函数的实际参数（实参）会被赋值给函数定义中的形式参数（形参）。这是一个赋值过程，而不是初始化
  形参赋值的性质
  赋值顺序：在函数调用时，实参从左到右依次赋值给对应的形参
  作用域：形参是在函数的局部作用域内有效，其值在函数调用时由实参赋值决定
  生命周期：形参的生命周期与函数执行周期相同，当函数返回时，形参的值就不再存在
  独立性：形参和实参是独立的变量，对形参的修改不会影响到实参（除非通过指针传递），指针传递的例外 当通过指针传递参数时，虽然形参和实参是独立的变量，但它们指向同一块内存区域，对形参的修改会影响实参指向的数据

  4、若将不确定值用作任何标准库调用的实参，则行为未定义。另外，任意牵涉到不确定值的表达式的值是不确定值（例如 int n;，n 可能与自身比较不相等，并且它在后续读取中的值可能出现更改）
  在C语言中，未初始化的变量包含不确定值（indeterminate value）。如果将这些不确定值用作标准库函数的实参，或在表达式中使用它们，会导致未定义行为（undefined behavior）。未定义行为意味着程序的结果是不可预测的，它可能崩溃、产生错误结果，甚至在不同的环境下表现出不同的行为
  
  不确定值 不确定值是指未初始化的变量可能包含的任意值。在下列情况下，变量会包含不确定值 当自动变量（局部变量）声明但未初始化时、当通过某些方式如未定义行为影响时
  未定义行为 
  如果使用包含不确定值的变量作为标准库函数的参数，则行为未定义
  不确定值在表达式中 任何包含不确定值的表达式，其结果也是不确定的。甚至，包含不确定值的变量在不同的读取操作中可能会得到不同的结果，即使它们在看似相同的条件下被读取

  安全编程实践 为了避免未定义行为和不确定值，应该始终确保变量在使用前被初始化

  5、C 中没有对应于 C++ 值初始化的专用语言构造；不过，可以代之以 = {0}（或复合字面量中的 (T){0}）(C99 起)，因为 C 标准不允许空结构体、空联合体或零长度的数组(C23前)，可以用空初始化式 = {}（或复合字面量中的 (T){}）来达成与 C++ 的值初始化相同的语义(C23起)
  C99 起：可以使用= {0}或复合字面量(T){0}来初始化变量，这样可以保证所有成员或变量本身都被初始化为零值
  C23 起：可以使用空初始化式= {}来达到与C++值初始化相同的效果
  这些初始化方式在编写C代码时可以提供更安全和更可预测的初始化行为
  */
  static int ac = 10;                   // 1、常量表达式
  static int bc = 5 + 5;                // 常量表达式
  static const int cc = 20;             // 常量表达式
  static int dc = cc;                   // 常量表达式，因为 cc 是 const 常量
  static char *str = "Hello, world!";   // 1、字符串字面量
  // int getValue();
  // static int agc = getValue();        // 错误：getValue()不是常量表达式

  // struct Incomplete;                  // 2、前向声明，不完整类型
  // struct Incomplete obj = {0};        // 错误：不能初始化不完整类型的对象，不完整类型：编译器无法确定对象的大小，因此无法分配内存和初始化
  // int vla[n];                         // 可变长度数组
  // vla = {1, 2, 3};                    // 错误：不能初始化可变长度数组，可变长度数组：数组大小在运行时确定，编译时无法提供初始化值
  // extern int x = 10;                  // 错误：extern int x具有外部链接属性，并且在块作用域内声明，因此不能在其声明时进行初始化
  extern int globalVar;                  // 声明外部变量，但不能初始化，在这个例子中，extern int globalVar;只是一个声明，它告诉编译器globalVar在其他地方定义（在这里是在全局作用域中定义的）。不能在这个声明中初始化globalVar
  globalVar = 10;                        // 可以在代码块中使用和修改这个变量
  // extern int globalVar = 10;          // 错误：不能为extern变量在块作用域内初始化
  static int localVar = 10;              // 正确：块作用域内的static变量可以初始化，对于块作用域内的static变量，它们可以在定义时进行初始化。static变量在整个程序生命周期内存在，但其作用域仅限于声明它的函数或代码块
  // extern int localVar = 20;           // 错误：不能在块作用域内使用extern初始化静态局部变量

  // void exampleFunction(int a, int b);    // 3、exampleFunction函数有两个形参a和b，在main函数中，exampleFunction被调用，并传递了实参x和y
  // int x = 5, y = 10;                     // 调用exampleFunction(x, y)时，实际发生的是，a被赋值为x的值，即5，b被赋值为y的值，即10
  // exampleFunction(x, y);                 // 函数调用，用实参 x 和 y

  int x;                                    // 4、x 未初始化，包含不确定值
  print_purple("%d\n", x);                  // 行为未定义，因为 x 未初始化，x未被初始化，直接使用它作为printf的参数会导致未定义行为
  int n;
  int m = n + 1;                            // m 的值是不确定的，因为 n 未初始化，由于n未初始化且包含不确定值，m的值也是不确定的。打印m的值会导致未定义行为
  print_purple("m = %d\n", m);

  struct Example { int a; float b; };
  struct Example e5 = {0};                  // 5、结构体的所有成员被初始化为零值
  int array5[10] = {0};                     // 数组的所有元素被初始化为零值
  int i5 = 0;                               // 基本数据类型被初始化为零值
  print_purple("e5.a = %d, e5.b = %f\n", e5.a, e5.b);
  print_purple("array5[0] = %d\n", array5[0]);
  print_purple("i5 = %d\n", i5);
  struct Example e6 = (struct Example){0};  // 使用复合字面量初始化结构体
  print_purple("e.a = %d, e.b = %f\n", e6.a, e6.b); 
  // struct Example e7 = {};                   // 使用空初始化式初始化结构体，C23 起：使用空初始化式 = {}，在C23之前，使用空初始化式可能会导致编译错误或未定义行为，因此推荐使用= {0}或复合字面量(T){0}来进行初始化
  // int array7[10] = {};                      // 使用空初始化式初始化数组
  // int i7 = {};                              // 使用空初始化式初始化基本数据类型 
  // print_purple("e7.a = %d, e7.b = %f\n", e7.a, e7.b);
  // print_purple("array7[0] = %d\n", array7[0]);
  // print_purple("i7 = %d\n", i7);  
  int i10;                                    // 初始化 i10 为不确定值
  static int j10;                             // 初始化 j10 为 0
  int k10 = 1;                                // 初始化 k10 为 1
  int x10[] = { 1, 3, 5 }, *p10 = x;          // 初始化 int x10[3] 为 1,3,5，初始化 int* p10 为 &x10[0]
  struct {int a[3], b;} w[] = {[0].a = {1}, [1].a[0] = 2}; // 初始化 w （二个结构体的数组）为 { { {1,0,0}, 0}, { {2,0,0}, 0} }  
  char* ptr10 = malloc(10);             // 函数调用表达式可用于局部变量初始化
  free(ptr10);
  // static char* ptr = malloc(10);           // 错误：拥有静态存储期的对象要求常量初始化器 
  // int vla[n] = {0};                        // 错误：不能初始化 VLA

  /*
  标量初始化
  标量类型：算术类型(布尔类型、字符类型、整数类型和浮点数类型) 和 指针类型以及 nullptr_t(C23起)
  类型组别
  对象类型：所有不是函数类型的类型
  字符类型：char、signed char、unsigned char
  整数类型：char、有符号整数类型、无符号整数类型、枚举类型
  实数类型：整数类型和实浮点数类型
  算术类型：整数类型和浮点数类型
  标量类型：算术类型和指针类型以及 nullptr_t(C23 起)
  聚合类型：数组类型和结构体类型
  派生声明符类型：数组类型、函数类型和指针类型

  在初始化标量类型对象时，初始化式必须是单个表达式
  标量（包含布尔和枚举类型的整数类型，包含复数和虚数的浮点类型，以及包含指向函数指针的指针类型对象）的初始化式必须是单个表达式，可选地以花括号环绕
  = 表达式	    (1)	
  = { 表达式 }	(2)	
  = { }	(3)	   (C23起)
  1,2) 表达式经过计算，在经过如同赋值转换为对象类型后，其值成为正在初始化的对象的初始值，即在标量初始化中，初始化式表达式的值被转换成待初始化对象的无限定类型，当你初始化一个标量类型（如int、float等）的变量时，初始化表达式的值会在赋值之前被转换为目标对象的类型。这是为了确保即使初始化表达式的类型和目标对象的类型不同，最终赋值的值是兼容的
  3) 空初始化对象，即对于算术或枚举类型对象初始化为数值零，或对指针类型对象初始化为空指针值

  标量初始化注解
  由于适用于赋值式转换的规则，在确定要将表达式转换为哪种类型时，声明类型上的 const 和 volatile 限定符将被忽略
  不使用初始化式时应用的规则见初始化，即隐式初始化
  同所有其他初始化，在初始化静态或线程局域存储期的对象时，表达式 必须为常量表达式，常量表达式是编译时就能求值的表达式，它们的值在编译阶段已经确定，不依赖于程序运行时的状态
  表达式 不能为逗号运算符（除非加括号），因为顶层的逗号会被转译为下个声明符的开始，在C语言中，如果使用逗号运算符进行初始化，必须小心，因为顶层的逗号可能会被解释为下一个声明符的开始，而不是逗号运算符的一部分。为了避免这种情况，可以使用括号将逗号运算符包围起来，使其明确表示为运算符，而不是声明符的分隔符

  在初始化浮点类型对象时，对所有拥有自动存储期的对象所作的计算如同在执行时进行，并受当前舍入影响；报告 math_errhandling 中指定的浮点错误。对于拥有静态和线程局域存储期的对象，计算如同在编译时进行，而且不引发异常
  在C语言中初始化浮点类型对象时，计算和错误处理的行为，具体取决于对象的存储期（storage duration）。存储期定义了对象在程序生命周期中的存在时间。C语言中有几种不同的存储期：自动存储期、静态存储期和线程局域存储期
  自动存储期通常与局部变量相关联，这些变量在函数调用期间存在，当函数返回时它们的生命周期结束，对于拥有自动存储期的浮点对象（如上例中的localVar），初始化表达式在运行时进行计算，并受当前的舍入模式影响。浮点计算的错误处理由宏math_errhandling指定
  静态存储期对象在程序的整个生命周期中都存在，这包括全局变量、具有static关键字的局部变量和函数内static变量，对于拥有静态存储期的浮点对象（如上例中的globalVar和staticLocalVar），初始化表达式在编译时进行计算。这意味着在程序执行之前，编译器已经计算并确定了初始化值。由于这些计算在编译时进行，它们不会受运行时舍入模式影响，也不会引发浮点异常  
  线程局域存储期 线程局域存储期对象在某个特定线程的整个生命周期内存在，这种存储期通常通过__thread或thread_local关键字实现（C11标准），对于拥有线程局域存储期的浮点对象（如上例中的threadVar），初始化表达式也在编译时进行计算。这些对象与静态存储期对象类似，在编译时进行计算，不会受运行时舍入模式影响，也不会引发浮点异常
  
  自动存储期的浮点对象：初始化表达式在运行时计算，受当前舍入模式影响，浮点错误按照math_errhandling宏的定义处理
  静态存储期的浮点对象：初始化表达式在编译时计算，不会受运行时舍入模式影响，也不会引发浮点异常
  线程局域存储期的浮点对象：初始化表达式在编译时计算，不会受运行时舍入模式影响，也不会引发浮点异常
  */
  float bf = 3.14;                  // 这里 3.14 是一个 double 常量，对于float bf = 3.14;，3.14是一个double类型的常量。在初始化f时，3.14会被转换为float类型
  int bi = 3.14;                    // 这里 3.14 是一个 double 常量，对于int bi = 3.14;，3.14仍然是一个double类型的常量。在初始化i时，3.14会被转换为int类型，结果变为3
  print_purple("bf = %f\n", bf);    // 输出：bf = 3.140000
  print_purple("bi = %d\n", bi);    // 输出：bi = 3 (double 值被转换为 int)
  double bd = 42;                   // 42 是一个 int 常量，对于double d = 42;，42是一个int类型的常量。在初始化d时，42会被转换为double类型
  char bcb = 1000;                  // 1000 是一个 int 常量，但超出 char 范围，对于char c = 1000;，1000是一个int类型的常量。由于char通常只能表示-128到127之间的数（假设是8位的char），1000会被截断并转换成char类型，结果可能是未定义的，但在很多实现中，结果是-24（因为1000 % 256 = 232，232在有符号char中的表示是-24）
  print_purple("bd = %f\n", bd);    // 输出：d = 42.000000
  print_purple("bcb = %d\n", bcb);  // 输出：c 的值取决于实现，通常为 -24（因为 1000 超出了 char 类型的范围，转换结果可能是未定义的）

  // int a, b, c;
  // a = (b = 1, c = 2);               // 使用括号明确表示这是一个逗号运算符表达式，在这个例子中，b先被赋值为1，然后c被赋值为2，最后整个表达式的值为c的值，亦即2，被赋值给a
  // int a = 1, 2;                     // 这是错误的语法，编译器会认为你在声明两个变量 a 和 2，编译错误，因为编译器会认为你在声明两个变量a和一个无效的变量2
  // int a = (1, 2);                   // 使用括号，逗号运算符表达式被正确解析，在这个例子中，括号中的逗号运算符首先计算1，然后计算2，并返回2作为整个表达式的值。因此，a被初始化为2
  // int a = (1, 2, 3);                // 逗号运算符表达式，返回最后一个值 3
  // printf("a = %d\n", a);            // 输出：a = 3  
  float flocalVar = 3.14159;           // flocalVar 具有自动存储期
  print_purple("localVar = %f\n", flocalVar); // 对于拥有自动存储期的浮点对象（如上例中的localVar），初始化表达式在运行时进行计算，并受当前的舍入模式影响。浮点计算的错误处理由宏math_errhandling指定。math_errhandling宏可以取以下两种值，MATH_ERRNO：错误会设置errno，MATH_ERREXCEPT：错误会引发浮点异常
  static float staticLocalVar = 2.71828;      // staticLocalVar 具有静态存储期
  print_purple("staticLocalVar = %f\n", staticLocalVar);  // 对于拥有静态存储期的浮点对象（如上例中的globalVar和staticLocalVar），初始化表达式在编译时进行计算。这意味着在程序执行之前，编译器已经计算并确定了初始化值。由于这些计算在编译时进行，它们不会受运行时舍入模式影响，也不会引发浮点异常
  static thread_local float threadVar = 1.61803;  // threadVar 具有线程局域存储期
  print_purple("threadVar = %f\n", threadVar);  // 对于拥有线程局域存储期的浮点对象（如上例中的threadVar），初始化表达式也在编译时进行计算。这些对象与静态存储期对象类似，在编译时进行计算，不会受运行时舍入模式影响，也不会引发浮点异常

  // #pragma STDC FENV_ACCESS ON        // 指示用于控制对浮点环境的访问和管理检测。它允许程序显式声明是否需要访问浮点环境，以便编译器进行相应的优化。这个指示只能出现在文件作用域或者复合语句的起始位置。如果你在其他位置使用这个指示，会导致编译错误。来看一下正确和错误的使用示例
  // static float v = 1.1e75;           // 不引发异常：静态初始化，v是一个具有静态存储期的浮点变量。静态存储期意味着它的初始化在编译时完成，因此不会在运行时引发浮点异常 
  // float u[] = { 1.1e75 };            // 引发 FE_INEXACT，u是一个具有自动存储期的浮点数组。自动存储期意味着它的初始化在运行时完成。如果数值1.1e75在表示为float时不能完全准确，将引发FE_INEXACT异常，因为需要舍入
  // float w = 1.1e75;                  // 引发 FE_INEXACT，同样，w是一个具有自动存储期的浮点变量，初始化时由于舍入可能会引发FE_INEXACT异常 
  // double x = 1.1e75;                 // 可能引发 FE_INEXACT（取决于 FLT_EVAL_METHOD），x是一个double类型的浮点变量。由于double通常有较高的精度，可能不会引发FE_INEXACT异常，但这取决于FLT_EVAL_METHOD。FLT_EVAL_METHOD决定了浮点表达式的计算方式，可能会影响是否引发异常
  // float y = 1.1e75f;                 // 可能引发 FE_INEXACT（取决于 FLT_EVAL_METHOD），y是一个float类型的浮点变量，但是使用了1.1e75f这个字面量。由于精度限制，初始化时可能会引发FE_INEXACT异常，这同样取决于FLT_EVAL_METHOD 
  // long double z = 1.1e75;            // 不引发异常（转换是准确的），z是一个long double类型的浮点变量。long double通常具有更高的精度和更大的范围，处理1.1e75这个数值时可以精确表示，因此不会引发FE_INEXACT异常  
  _Bool b11 = true;
  const double d11 = 3.14;
  int k11 = 3.15;                         // 从 double 转换到 int
  int n11 = {12},                         // 可选地花括号
  *p11 = &n11,                            // 对自动对象，非常量表达式 OK
  (*fp11)(void);
  enum {RED, BLUE} e11 = RED;             // 枚举亦是标量类型

  /*
  数组初始化
  */
  

  /*
  结构体及联合体初始化
  */

#endif // INITIALIZATION initialization

  return 0;
}