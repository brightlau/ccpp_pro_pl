/**
* @file              expressions.c
* @brief             表达式 是运算符及其操作数的序列，它指定一个运算
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.28
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.28 <td>0.1             <td>brightl         <td>表达式使用，解释说明
* </table>
*/

#include "c/basics/expressions/expressions.h"
#include "colorfmt.h"
#include <stdio.h>

/**
* @brief             表达式是运算符及其操作数的序列，它指定一个运算
*
* @note              表达式求值可以产生结果（例如求值 2 + 2 产生结果 4 ，可能产生副效应（例如求值 printf("%d", 4) 会将字符 '4' 送到标准输出流），并可以指代对象或函数
*/
#define EXPRESSIONS
void print_int(int x) { printf("Integer: %d\n", x); }
void print_float(float x) { printf("Float: %f\n", x); }
#define PRINT(X) _Generic((X), \
    int: print_int,            \
    float: print_float         \
)(X)

/**
* @brief             在C语言中，表达式是运算符和操作数（可以是常量、变量或函数调用等）的组合，用于指定一个计算过程。根据ISO/IEC 9899:2011标准，表达式的定义为“由一系列运算符和操作数组成的序列，该序列指定了值的计算、对象或函数的指定、副作用的产生，或是这些目的的组合” 下面我们将通过具体的例子来解释说明C语言中的表达式及其求值行为
* @return  int       Return Description
*
* @note              C语言中的表达式不仅仅是简单的数学公式，它们能够执行多种任务，包括但不限于计算新值、引用现有对象以及触发各种副作用。理解如何正确构建和解读这些表达式对于编写高效且易于维护的C程序至关重要
*/
int expressions_fn(void) {
#ifdef EXPRESSIONS
  /*
  表达式是运算符及其操作数的序列，它指定一个运算。
  表达式求值可以产生结果（例如求值 2 + 2 产生结果 4 ，可能产生副效应（例如求值 printf("%d", 4) 会将字符 '4' 送到标准输出流），并可以指代对象或函数
  在C语言中，表达式是运算符和操作数（可以是常量、变量或函数调用等）的组合，用于指定一个计算过程。根据ISO/IEC 9899:2011标准，表达式的定义为“由一系列运算符和操作数组成的序列，该序列指定了值的计算、对象或函数的指定、副作用的产生，或是这些目的的组合2。” 下面我们将通过具体的例子来解释说明C语言中的表达式及其求值行为

  1、表达式的类型 
  - 计算数值：最直观的表达式形式就是用来计算数值的结果
  - 指代对象或函数：表达式还可以用来指代特定的对象或函数。比如，在下面的例子中，x 和 y 分别是指向各自存储位置的对象标识符；而 printf 则是指向标准库中定义的一个输出函数
  - 产生副作用：副作用指的是执行某个操作时对程序状态的影响，即使这种影响不是直接返回的结果。例如，赋值操作就是一个典型的具有副作用的操作，因为它改变了目标变量的值。另一个常见的例子是输入/输出操作，如 scanf 或 printf 函数的调用，它们会在执行过程中修改外部资源的状态
  表达式的属性，每个表达式都有其自身的属性
  - 值：表达式求值后所得到的具体数值
  - 类型：与表达式的值相关联的数据类型
  - 副作用：如果有的话，表达式求值期间发生的任何额外操作，如改变全局变量的值、进行I/O操作等

  值类别：（左值、非左值对象、函数指示符）根据表达式的值对表达式进行分类
  求值顺序：参数和子表达式的求值顺序指定了获得中间结果的顺序
  常量表达式：常量表达式可以在编译时进行计算，并在编译时上下文中使用（自C99起的非可变长度数组 VLA 大小、静态初始化器等）
  转换：隐式转换在操作数类型与运算符的预期不匹配时发生、强制类型转换可用于显式地将值从一种类型转换为另一种类型
  泛型选择：可根据参数的类型执行不同的表达式”（自C11起）
  2、在C语言中，值类别、求值顺序、常量表达式、转换以及泛型选择是编程时需要考虑的重要概念。下面我们将逐一解释这些概念，并提供具体的例子来帮助理解
  - 值类别：C语言中的表达式可以根据其值被分类为左值（lvalue）、非左值对象（rvalue）和函数指示符。左值是指那些可以出现在赋值语句左侧的表达式，它们代表持久存在的对象，非左值对象也称为右值（rvalue），是指那些不指向任何持久存储位置的临时值或常量，函数指示符则是指函数的名字，当用作表达式时，它被视为指向该函数的指针
  - 求值顺序：C语言对某些运算符规定了明确的求值顺序，如逻辑与（&&）、逻辑或（||）、条件运算符（?:）及逗号运算符（,）。对于其他大多数运算符而言，C标准并没有明确规定它们的操作数之间的求值顺序7。这意味着编译器可以选择任意顺序来评估表达式的各个部分，这可能导致不可预测的行为，尤其是在存在副作用的情况下
  - 常量表达式：自C99以来，C语言允许使用常量表达式来确定数组大小、枚举值以及其他静态初始化场景8。这类表达式的特点是在编译阶段就能完全确定其结果，因此可以在编译期间进行优化处理
  - 转换：C语言支持两种类型的类型转换：隐式转换和显式转换（强制类型转换）。隐式转换发生在操作数类型不符合运算符要求时自动进行；而显式转换则通过程序员指定的方式改变数据类型
  - 泛型选择：从C11开始，C语言引入了_Generic关键字，使得根据参数类型选择不同实现成为可能22。这允许编写更加灵活且通用的代码，类似于其他语言中的模板或泛型机制

  浮点数算术：可能会引发浮点数异常，并报告 math_errhandling 中指定的错误
  标准 #pragma：FENV_ACCESS、FP_CONTRACT 及 CX_LIMITED_RANGE 还有浮点数求值精度和舍入方向控制浮点数算术求值方式

  初等表达式：运算符的操作数可为其他表达式，或初等表达式（例如 1 + 2 * 3 中，运算符 + 的操作数是子表达式 2 * 3 和初等表达式 1）
  初等表达式可以是下列之一：
  - 常量及字面量（例如 2 或 "Hello, world"）
  - 适合的已声明标识符（例如 n 或 printf）
  - 泛型选择(C11起)
  
  任何在括号中的表达式亦被分类为基础表达式：这保证括号拥有高于任何运算符的优先级

  常量及字面量：某些类型的常量值可用称为字面量（对于左值表达式）和常量（对于右值表达式）的特殊表达式嵌入到 C 程序源代码中
  - 整数常量是十进制、八进制或十六进制的整数类型数字
  - 字符常量是 int 类型的单个字符，适合转换为字符类型或char8_t类型（自C23起）、char16_t、char32_t 或者（自C11起）wchar_t类型
  - 浮点数常量是 float、double 或 long double 类型的值
  - 预定义常量 true/false 是 bool 类型的值(C23起)
  - 预定义常量 nullptr 是 nullptr_t 类型的值(C23起)
  - 字符串字面量是类型为 char[]、char8_t[](C23起)、char16_t[]、char32_t[] (C11起)或 wchar_t[] 的一系列字符，它们表示以空字符结尾的字符串
  - 复合字面量是直接嵌入程序代码的结构体、联合体或数组类型的值(C99起)

  运算符：赋值、自增自减、算术、逻辑、比较、成员访问、其他
  - 运算符优先级定义运算符绑定到其实参的顺序
  - 代用表示是一些运算符的代用写法
  - | 类别       | 运算符                                                                                         |
  - |------------|------------------------------------------------------------------------------------------------|
  - | 赋值   | =, +=, -= , *= , /= , %= , &= , |= , ^= , <<= , >>=                      |
  - | 自增   | ++a (前缀), a++ (后缀)                                                                      |
  - | 自减   | --a (前缀), a-- (后缀)                                                                      |
  - | 算术   | +a (正号), -a (负号), a + b, a - b, a * b, a / b, a % b, ~a (按位非)           |
  - | 逻辑   | !a (逻辑非), a && b (逻辑与), a || b (逻辑或)                                             |
  - | 比较   | a == b, a != b, a < b, a > b, a <= b, a >= b                                       |
  - | 成员访问 | a[b] (数组索引), *a (解引用), &a (取地址), a->b (指针成员访问), a.b (对象成员访问) |
  - | 其他   | a(...) (函数调用), a, b (逗号表达式), (type) a (类型转换), a ? b : c (条件运算符), sizeof (大小), _Alignof (对齐)[ty-reference](24) |
  - 注：对于C11标准引入的_Alignof和C23标准中的alignof，它们用于查询数据类型的内存对齐要求

  sizeof 运算符的操作数是不求值的表达式（除非它们是 VLA）(C99起)。故而 size_t n = sizeof(printf("%d", 4)); 不会进行控制台输出
  _Alignof(C23前)alignof(C23起) 运算符的操作数、泛型选择的控制表达式及作为 _Alignof(C23前)alignof(C23起) 的操作数的 VLA 的大小表达式亦为不求值的表达式
  */
  print_purple("expression start...\n");
  int result = 3 + 4;                   // 1、计算数值，在这个例子中，3 + 4 是一个表达式，它指定了两个整数相加的操作，并且最终会得到一个值 7。这个结果随后被赋给名为 result 的变量
  int x = 5, y = 6;
  printf("Sum is %d\n", x + y); // 指代对象或函数，这里，x + y 是一个表达式，它不仅计算了两个整数的和，还作为参数传递给了 printf 函数，后者负责将结果打印到控制台
  printf("%d", 4);              // 产生副作用，输出数字 '4' 到标准输出流，这段代码中，printf("%d", 4) 不仅是一个表达式，而且它的求值还会导致字符 '4' 被发送到标准输出流，这就是所谓的副作用
  int a = 10, b = 5, c;
  c = ++a * (b-- + 2);                 // 在这个例子中，我们有一个复合表达式 ++a * (b-- + 2)，其中包含了前置递增 (++a) 和后置递减 (b--) 运算符。当这个表达式被求值时，首先会对 a 执行前置递增，使其从 10 变为 11，然后计算括号内的表达式 (b-- + 2)，此时 b 的当前值为 5，所以加上 2 后等于 7，但因为使用了后置递减，所以在整个表达式求值完毕之后，b 的值才会减小到 4。最后，11 * 7 得到 77 并将其赋给 c。因此，最终 c 的值为 77，同时 a 等于 11，而 b 等于 4 

  int x1 = 5;                          // 2、值类别 'x1' 是一个左值，因为它表示一个具有固定地址的对象
  int y1 = x1 + 1;                     // 'x1 + 1' 是一个右值，它计算后立即销毁
  int a1 = 1;
  a1 = a1++ + ++a1;                    // 这样的代码会导致未定义行为，因为没有规定哪个操作先执行
  #define ARRAY_SIZE 10
  int arr[ARRAY_SIZE];                 // ARRAY_SIZE 是一个常量表达式，在编译时就被解析
  double d = 3.14;
  int i = (int)d;                      // 显式转换：将 double 类型转换成 int 类型，隐式转换的例子包括算术转换规则，其中较小的数据类型会提升到较大的类型以确保精度
  PRINT(42);
  PRINT(3.14f);                        // 隐式选择：在这个例子中，PRINT宏利用_Generic关键字检查传入参数的类型，并调用相应的打印函数。这样就可以针对不同类型的数据提供不同的处理逻辑，从而实现了某种程度上的泛型编程能力

  print_purple("expression end...\n");

#endif // EXPRESSIONS  expressions 表达式  

  return 0;
}