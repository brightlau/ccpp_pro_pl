/**
* @file              valueCategory.c
* @brief             brief
* @version           0.1
* @author            brightl birigtl3016@outlook.com
* @date              2024.12.28
* @copyright         Copyright (c) 2024.
*
* @note              Revision History:
* <table>
* <tr><th>Date       <th>Version         <th>Author          <th>Description
* <tr><td>2024.12.28 <td>0.1             <td>brightl         <td>description
* </table>
*/

#include "c/basics/expressions/expressions.h"
#include "colorfmt.h"
#include <stdio.h>

/**
* @brief             brief
*
* @note              Revision History
*/
#define VALUE_CATEGORY

/**
* @brief             brief
* @return  int       Return Description
*
* @note              Revision History
*/
int valueCategory_fn(void) {
#ifdef VALUE_CATEGORY
  /*
  在 C 语言中，每个表达式（带参数的运算符、函数调用、常量、变量名等）具有两个独立的属性：一个类型和一个值类别
  1、每个表达式都属于三种值类别之一：左值、非左值对象（右值）和函数指示符

  左值表达式：
  左值表达式是除类型 void 之外的任何对象类型，且隐含地指代一个对象的表达式（当左值在求值时不实际指代一个对象时，行为未定义）。换言之，左值表达式求值得到对象标识。此值类别的名称（“左值”）是历史性的，并反映了 CPL 中，左值表达式作为赋值运算符的左运算数
  2、在C语言中，左值表达式（lvalue expression）是指那些可以标识内存中特定位置的对象的表达式。当一个表达式求值时，它不仅返回一个值，还隐含地指向了这个值存储的位置。这种表达式的名称“左值”来源于历史上的CPL语言，其中左值表达式可以作为赋值运算符的左侧操作数11。接下来我们将逐句解释并举例说明这些概念
  - 左值表达式的定义 除类型 void 之外的任何对象类型，且隐含地指代一个对象的表达式，这句话的意思是，左值表达式不能是指向 void 类型的数据，因为 void 表示没有类型或不确定类型的值。而其他所有具有确定类型的对象都可以构成左值表达式
  - 当左值在求值时不实际指代一个对象时，行为未定义，如果一个左值表达式在运行时并不真正指向一个有效的内存位置，则其行为是未定义的。例如，试图访问一个已经释放了的动态分配内存区域或者超出数组边界的情况都可能导致未定义行为
  - 左值表达式求值得到对象标识，这意味着左值表达式的求值结果不仅仅是一个值，而是包含了该值所在内存位置的信息
  左值表达式的使用场景语境
  - 作为取址运算符的操作数，只要不是位域或声明为 register 的变量，左值表达式可以用作取地址运算符 & 的操作数
  - 作为前/后自增减运算符的操作数，只有左值表达式才能用作前置或后置自增(++)和自减(--)运算符的操作数，因为这些运算符需要修改对象的内容
  - 作为成员访问（点）运算符的左操作数，结构体或联合体成员可以通过点运算符.来访问，前提是左边的操作数必须是一个左值表达式
  - 作为赋值及复合赋值运算符的左操作数，左值表达式也可以出现在赋值运算符 = 或者复合赋值运算符（如 +=, -= 等）的左侧
  若将左值表达式用于除 sizeof、_Alignof 或上述的运算符之外的语境，则任何完整类型的非数组左值会经历左值转换，这模仿的是从对象位置到其值的内存加载。同样地，在用于除 sizeof、_Alignof、取址运算符或从字符串字面量初始化数组之外的语境时，数组左值会经历数组到指针转换
  - 当左值表达式用于非上述特殊运算符（如 sizeof, _Alignof）的情境下时，会发生所谓的“左值转换”，即从对象的位置信息转换成单纯的值；
  const/volatile/restrict 限定符和原子类型的语义仅应用于左值（左值转换将剥除限定符并移除原子属性）
  - 这些限定符以及原子类型的语义仅应用于左值表达式。一旦发生了左值转换，这些限定属性就会丢失，也就是说，限定符不会影响到最终使用的值本身

  下列表达式是左值：
  - 标识符，标识符是指变量名或函数参数名，只要它们声明为指代对象而不是函数或枚举常量
  - 字符串字面量，从 C99 标准开始，字符串字面量也被认为是左值。然而，它们位于只读内存区域，尝试修改这些字面量会导致未定义行为。因此，虽然技术上是左值，但不应该对它们进行修改
  - (C99) 复合字面量，复合字面量允许创建匿名结构体、联合体或数组，并且可以对其取地址，这意味着它们也是左值
  - 括号表达式，如果一个表达式的无括号版本是左值，那么加上括号后仍然是左值
  - 成员访问（点）运算符的结果，当使用成员访问运算符.时，如果左边的操作数是一个左值，则结果也是一个左值
  - 通过指针访问成员（->）运算符的结果，对于指向结构体或联合体的指针，使用箭头运算符->访问其成员也会产生一个左值
  - 对指向对象指针运用间接使用（一元 *）运算符的结果，应用解引用运算符*到指向对象的指针会得到该对象的位置，即一个左值
  - 下标运算符的结果，数组元素访问会产生左值表达式，允许我们对特定索引处的元素进行读写操作

  可修改左值表达式：一个可修改左值是任何完整的非数组类型的、非 const 限定的左值表达式，而且若它是结构体/联合体，则递归地没有任何成员为 const 限定，只有可修改左值表达式可用作自增减运算符的实参，赋值和复合赋值运算符的左实参
  在C语言中，可修改左值表达式（modifiable lvalue）是指那些不仅标识内存中的位置，而且允许对所标识的对象进行修改的左值表达式。具体来说，一个可修改左值必须满足以下条件
  - 它是一个非 const 限定的完整类型（即不是 void 类型或函数类型）
  - 如果它是结构体或联合体，则该结构体或联合体及其成员都不能被 const 限定符修饰
  - 它不是一个数组类型
  只有可修改左值可以作为自增减运算符（如 ++, --）、赋值运算符（如 =）和复合赋值运算符（如 +=, -= 等）的操作数。这是因为这些操作需要改变对象的内容，而不可修改的左值不允许这样的更改

  非左值对象表达式：

  函数指代符表达式：
  */
  print_purple("valueCategory start...\n");
  int x = 5;                                       // 2、'x' 是一个左值表达式，这里的 x 是一个整型变量，它既代表了一个具体的数值也代表了该数值在内存中的位置
  int y = 10;                                      // 对左值表达式的求值结果不仅仅是一个值，而是包含了该值所在内存位置的信息，y 的值被用来打印输出，而它的地址则通过取地址运算符 & 获取
  printf("Value of y: %d\n", y);           // 使用y的值
  printf("Address of y: %p\n", (void*)&y); // 使用y的位置
  int z = 20;
  int *pz = &z;                                    // &z 是合法的，因为它指向一个有效的内存位置
  int a = 3;
  a++;                                             // 合法，a 是左值
  // (a + 1)++;                                    // 非法，(a + 1) 不是左值
  struct Point {
    int x;
    int y;
  };
  struct Point p = {1, 2};
  p.x = 10;                                        // 合法，p.x 是左值
  int b = 4;
  b += 6;                                          // 合法，b 是左值
  int arr[5] = {0, 1, 2, 3, 4};
  int first_element = arr[0];                      // arr[0] 是左值，但在这里只关心它的值
  int *ptr = arr;                                  // arr 自动转换为指向第一个元素的指针
  const int c = 7;
  // c = 8; // 错误：c 是常量，不能重新赋值
  int *pc = (int *)&c;                             // 强制转换移除了 const 属性
  *pc = 9;                                         // 编译器允许这样做，但实际行为可能未定义
  int x1 = 5;
  x1 = 10;                                         // 'x1' 是一个左值，可以对其进行赋值操作，这里 x 是一个整型变量，它既代表了一个具体的数值也代表了该数值在内存中的位置
  char *str = "hello";                             // "hello" 是一个字符串字面量
  // str[0] = 'H';                                 // 不要这样做！这将导致未定义行为
  struct Point1 {
    int x, y;
  };
  // 创建一个匿名结构体并对其取地址
  struct Point1 *p1 = &(struct Point1){10, 20};
  p1->x = 30;                                     // 合法：复合字面量是左值
  int a1 = 1;
  (a1) = 2;                                       // 合法：即使有括号，'a1' 依然是左值
  struct Point p2 = {1, 2};
  p2.x = 10;                                      // 合法：p2.x 是左值
  struct Point *ptr1 = &p;
  ptr1->y = 20;                                   // 合法：ptr1->y 是左值
  int value = 42;
  int *ptr2 = &value;
  *ptr2 = 84;                                     // 合法：*ptr2 是左值
  int arr1[3] = {0, 1, 2};
  arr1[1] = 99;                                   // 合法：arr1[1] 是左值
  int x2 = 5;                                     // 'x2' 是一个可修改左值，因为它不是 const，并且是完整的非数组类型
  x2++;                                           // 合法：x2 是可修改左值，可以对其进行自增操作
  struct Point2 {
      int x;
      int y;
  } p3 = {1, 2};
  p3.x = 10;                                      // 合法：p3.x 是可修改左值，可以对其进行赋值操作 
  const int c1 = 7;                               // 'c' 是左值但不可修改，因为它被 const 限定
  // c1++;                                        // 错误：不能对 const 对象使用自增操作
  const struct Point2 cp = {3, 4};
  // cp.x = 5;                                    // 错误：cp.x 是左值但不可修改，因为 cp 被 const 限定
  int arr2[3] = {0, 1, 2};
  // arr2 = {1, 2, 3};                            // 错误：arr2 是数组类型，所以它不是可修改左值
  struct Person {
    char name[20];
    int age;
  };
  struct Person person = {"Alice", 30};
  // person.name 是数组类型，因此不是可修改左值，但是它的元素是可修改的
  person.name[0] = 'B';                          // 合法：person.name[0] 是可修改左值
  // person.age 是可修改左值，因为它既不是 const 限定也不是数组类型
  person.age = 31;                               // 合法：person.age 是可修改左值，可以对其进行赋值操作
  int value1 = 42;
  int * const ptrv1 = &value;                    // 常量指针（如 int * const ptr = &x;）意味着指针本身不能改变，但它指向的对象可以被修改
  *ptrv1 = 84;                                   // 合法：虽然 ptrv1 是常量指针，但它指向的对象是可以修改的
  const int const_value = 99;
  const int *ptrv2 = &const_value;               // 指向常量的指针（如 const int *ptr = &x;）意味着指针指向的对象不能被通过该指针修改，但指针本身可以指向其他对象
  // *ptrv2 = 100;                               // ptrv2 是指向常量的指针，不能修改指向的对象  
  // 原子类型 C11 引入了 _Atomic 类型限定符用于定义原子类型的变量。原子类型的对象只能通过特定的原子操作来访问，它们通常不被视为可修改左值，除非明确指定为可变的

  print_purple("valueCategory end...\n");

#endif // VALUE_CATEGORY  valueCategory 表达式  

  return 0;
}