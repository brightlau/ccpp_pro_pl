# 科学计算器的多种实现方法

以下是实现完整科学计算器的几种主要方法，每种方法都有其独特的特点和适用场景：

## 一、栈求值法- 基于调度场算法 (Shunting Yard Algorithm) 

### 1. 核心目的

**将人类易读的中缀表达式转换为计算机易处理的后缀表达式（逆波兰表示法），然后使用栈计算后缀表达式值**

- 中缀表达式：`3 + 4 * (5 - 2)`

- 后缀表达式：`3 4 5 2 - * +`

**转换目的**：

- 消除括号需求：后缀表达式无需括号即可明确运算顺序

- 简化计算过程：计算机可通过栈结构高效计算后缀表达式

- 统一处理规则：为编译器/解释器提供标准化的表达式处理方案

### 2. 核心原理

**数据结构与功能**：

- 输入序列：存储待处理的中缀表达式标记流（tokens）包含操作数、运算符、括号等基本元素，按原始表达式顺序排列
- 运算符栈：临时存储运算符和括号，处理优先级和结合性的核心容器
- 输出队列：存放最终的后缀表达式，接收操作数和有序运算符，队列顺序即后缀表达式顺序

**优先级与结合性规则**：

- 优先级：`^` > `*/` > `+-`（指数>乘除>加减）
- 结合性：左结合：`+ - * /`（从左向右计算）、右结合：`^`（从右向左计算）

### 3. 实现步骤

**数据结构**

- 输出队列：存放最终后缀表达式
- 运算符栈：临时存放运算符和括号

**处理规则（从左到右扫描表达式）**

- 遇到操作数（数字、变量）→ 直接加入输出队列。*例：`3` → 输出 `[3]`*

- 遇到运算符（`+ - * / ^`）。*例：处理 `+` 时，若栈顶有优先级更高的 `\*`，先弹出 `\*`*

  ```c
  // while (栈非空 and 栈顶不是左括号 and (栈顶优先级 > 当前优先级 or (优先级相同 and 左结合))) {
  //    弹出栈顶运算符加入输出队列
  // }
  // 当前运算符入栈
  ```

- 遇到左括号 `(` → 直接压入运算符栈。*例：`(` 入栈，标记子表达式开始*

- 遇到右括号 `)` 。*例：遇到 `)` 时，弹出 `(` 之前所有运算符*

  ```c
  // while 栈顶不是左括号 {
  //   弹出栈顶运算符加入输出队列 
  // }
  // 弹出左括号（丢弃不输出）
  ```

- 扫描结束 → 将栈中剩余运算符全部弹出加入输出队列

### 4. 实例解析

**例1：基础表达式 `3 + 4 * 5`**

| 当前符号 | 操作                | 输出队列      | 运算符栈 | 说明               |
| -------- | ------------------- | ------------- | -------- | ------------------ |
| `3`      | 加入输出            | `[3]`         | `[]`     | 数字直接输出       |
| `+`      | 入栈                | `[3]`         | `[+]`    | 栈空直接入栈       |
| `4`      | 加入输出            | `[3,4]`       | `[+]`    |                    |
| `*`      | 入栈（优先级>栈顶） | `[3,4]`       | `[+,*]`  | `*` 优先级高于 `+` |
| `5`      | 加入输出            | `[3,4,5]`     | `[+,*]`  |                    |
| **结束** | 弹出栈中所有运算符  | `[3,4,5,*,+]` | `[]`     | 先弹 `*` 后弹 `+`  |

**结果**：`3 4 5 * +`

---

**例2：带括号表达式 `(3 + 4) * 5`**

| 当前符号 | 操作           | 输出队列      | 运算符栈 | 说明              |
| -------- | -------------- | ------------- | -------- | ----------------- |
| `(`      | 入栈           | `[]`          | `[(]`    |                   |
| `3`      | 加入输出       | `[3]`         | `[(]`    |                   |
| `+`      | 入栈           | `[3]`         | `[(,+]`  | 栈顶是 `(` 可入栈 |
| `4`      | 加入输出       | `[3,4]`       | `[(,+]`  |                   |
| `)`      | 弹出直到 `(`   | `[3,4,+]`     | `[]`     | 弹出 `+` 丢弃 `(` |
| `*`      | 入栈           | `[3,4,+]`     | `[*]`    |                   |
| `5`      | 加入输出       | `[3,4,+,5]`   | `[*]`    |                   |
| **结束** | 弹出栈中运算符 | `[3,4,+,5,*]` | `[]`     |                   |

**结果**：`3 4 + 5 *`

---

**例3：复杂表达式 `3 * 2 ^ 3 + 4`**（假设 `^` 优先级最高且右结合）

| 当前符号 | 操作                    | 输出队列          | 运算符栈 | 说明               |
| -------- | ----------------------- | ----------------- | -------- | ------------------ |
| `3`      | 加入输出                | `[3]`             | `[]`     |                    |
| `*`      | 入栈                    | `[3]`             | `[*]`    |                    |
| `2`      | 加入输出                | `[3,2]`           | `[*]`    |                    |
| `^`      | 入栈（优先级>栈顶）     | `[3,2]`           | `[*,^]`  | `^` 优先级高于 `*` |
| `3`      | 加入输出                | `[3,2,3]`         | `[*,^]`  |                    |
| `+`      | 弹出栈顶直到优先级<当前 | `[3,2,3,^,*]`     | `[+]`    | 先弹 `^` 再弹 `*`  |
| `4`      | 加入输出                | `[3,2,3,^,*,4]`   | `[+]`    |                    |
| **结束** | 弹出栈中运算符          | `[3,2,3,^,*,4,+]` | `[]`     |                    |

**结果**：`3 2 3 ^ * 4 +`  计算顺序：`2^3=8 → 3*8=24 → 24+4=28`

---

**例4：函数处理 `max(3, 5) + 2`**

| 当前符号 | 操作               | 输出队列        | 运算符栈  | 说明           |
| -------- | ------------------ | --------------- | --------- | -------------- |
| `max`    | 入栈               | `[]`            | `[max]`   | 函数视为运算符 |
| `(`      | 入栈               | `[]`            | `[max,(]` |                |
| `3`      | 加入输出           | `[3]`           | `[max,(]` |                |
| `,`      | 忽略（参数分隔符） | `[3]`           | `[max,(]` |                |
| `5`      | 加入输出           | `[3,5]`         | `[max,(]` |                |
| `)`      | 弹出直到 `(`       | `[3,5]`         | `[max]`   | 丢弃 `(`       |
|          | 弹出栈顶函数       | `[3,5,max]`     | `[]`      | 函数加入输出   |
| `+`      | 入栈               | `[3,5,max]`     | `[+]`     |                |
| `2`      | 加入输出           | `[3,5,max,2]`   | `[+]`     |                |
| **结束** | 弹出栈中运算符     | `[3,5,max,2,+]` | `[]`      |                |

**结果**：`3 5 max 2 +`

### 5. 优缺点

**优点**：结构清晰、易于处理运算符优先级、支持复杂表达式

**缺点**：需要显式处理括号、函数处理较复杂

### 6. 算法特性

**时间复杂度**：O(n) 线性扫描表达式

**空间复杂度**：O(n) 栈和队列的存储需求

**确定性**：同一表达式每次转换结果相同

**可扩展性**：支持自定义函数和运算符

### 7. 典型应用场景

- 编程语言编译器（表达式解析阶段）
- 科学计算器软件（如Windows计算器）
- 数据库查询优化器（SQL条件表达式处理）
- 电子表格公式计算（Excel等）
- 数学软件（MATLAB, Mathematica）

通过调度场算法，计算机得以高效处理人类直观的数学表达式，架起了自然数学表示与机器高效执行之间的关键桥梁。其设计体现了迪杰斯特拉"分而治之"的思想精髓，是算法设计中栈结构应用的经典范例。

## 2. 递归下降解析 (Recursive Descent Parsing)

### 原理
- 基于**上下文无关文法**
- 使用一组相互递归的函数
- 每个函数处理特定语法结构

### 文法示例
```
expression → term { ('+' | '-') term }
term → factor { ('*' | '/') factor }
factor → base { '^' factor } | '!' factor
base → number | '(' expression ')' | function '(' expression ')'
```

### 优点
- 代码结构清晰
- 易于扩展新语法
- 自然支持嵌套表达式

### 缺点
- 递归深度可能受限
- 需要处理左递归问题
- 错误处理较复杂

## 3. 抽象语法树 (Abstract Syntax Tree, AST)

### 原理
1. 词法分析：将输入分解为token流
2. 语法分析：构建语法树
3. 树遍历求值

### 节点类型
- 操作符节点：+, -, *, /, ^
- 函数节点：sin, cos, log等
- 数值节点
- 括号节点

### 优点
- 最灵活的方法
- 支持复杂语法分析
- 易于优化和转换
- 可生成中间代码

### 缺点
- 实现最复杂
- 内存开销较大
- 需要完整解析器

## 4. 表驱动解析 (Table-Driven Parsing)

### 原理
- 使用**有限状态机**(FSM)
- 状态转换表驱动解析
- 结合运算符优先级表

### 组件
- 状态表：定义状态转换
- 优先级表：处理运算符优先级
- 语义动作：执行计算

### 优点
- 高效且可预测
- 易于添加新运算符
- 适合嵌入式系统

### 缺点
- 表结构可能复杂
- 函数支持有限
- 错误恢复困难

## 5. 混合方法 (Hybrid Approach)

### 常见组合
1. **栈 + 递归**：主表达式用栈处理，函数参数递归计算
2. **AST + 访客模式**：构建AST后使用访客模式求值
3. **递归下降 + 优先级爬升**：结合递归下降和运算符优先级

### 示例实现
```c
double expression() {
    double result = term();
    while (current_token == '+' || current_token == '-') {
        char op = current_token;
        next_token();
        double right = term();
        result = (op == '+') ? result + right : result - right;
    }
    return result;
}

double term() {
    double result = factor();
    while (current_token == '*' || current_token == '/') {
        char op = current_token;
        next_token();
        double right = factor();
        result = (op == '*') ? result * right : result / right;
    }
    return result;
}

double factor() {
    double result = base();
    while (current_token == '^') {
        next_token();
        double exponent = factor();
        result = pow(result, exponent);
    }
    if (current_token == '!') {
        next_token();
        result = factorial(result);
    }
    return result;
}
```

## 6. 基于词法分析的直接求值 (Lexer-Based Direct Evaluation)

### 原理
- 单次扫描输入
- 即时计算部分结果
- 维护当前值和运算符状态

### 特点
- 高效但有限
- 仅支持左结合运算
- 难以处理优先级和括号

## 方法比较

| 方法 | 复杂度 | 灵活性 | 性能 | 适合场景 |
|------|--------|--------|------|----------|
| 栈求值 | 中等 | 中等 | 高 | 通用计算器 |
| 递归下降 | 中等 | 高 | 中 | 教学/扩展型计算器 |
| AST | 高 | 很高 | 中 | 编译器/复杂系统 |
| 表驱动 | 中高 | 低 | 很高 | 嵌入式系统 |
| 混合方法 | 可变 | 高 | 高 | 专业计算器 |
| 直接求值 | 低 | 很低 | 很高 | 简单计算器 |

## 选择建议

1. **通用科学计算器**：栈求值法或递归下降法
2. **高性能需求**：表驱动或直接求值
3. **教育目的**：递归下降（易于理解）
4. **专业应用**：AST方法（最大灵活性）
5. **嵌入式系统**：表驱动或直接求值

实际实现中，栈求值法和递归下降法最为常用，它们平衡了实现复杂度、性能和功能扩展性。本文第一个实现使用的就是栈求值法，而混合方法在专业计算软件中也很常见。